var documenterSearchIndex = {"docs":
[{"location":"#Replication-of-\"Public-Debt,-Interest-Rates,-and-Negative-Shocks\"-(Evans,-R.-2020)","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"","category":"section"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"This replication study was part of our evaluation for the course Numerical Methods at SciencesPo Paris in Spring 2021The functions used to replicate this paper are:","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"Modules = [Evans2020]","category":"page"},{"location":"#Evans2020.LN_pdf-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.LN_pdf","text":"LN_pdf\n\nThis function gives the PDF of the lognormal distribution for xvals\ngiven mu and sigma\n(LN): f(x; mu, sigma) = (1 / (x * sigma * sqrt(2 * pi))) *\n        exp((-1 / 2) * (((log(x) - mu) / sigma) ** 2))\n       x in [0, infty), mu in (-infty, infty), sigma > 0\n\nINPUTS:\nxvals = (N,) vector, data\nmu    = scalar, mean of the ln(x)\nsigma = scalar > 0, standard deviation of ln(x)\nOTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None\nOBJECTS CREATED WITHIN FUNCTION:\npdf_vals        = (N,) vector, probability of each observation given\n                  the parameter values\nFILES CREATED BY THIS FUNCTION: None\nRETURNS: pdf_vals\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_1pr_MU_c2_pdf-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_1pr_MU_c2_pdf","text":"get_1pr_MU_c2_pdf     This function is the target for calculating the integral     (expectation): E[(1+r{tp1})*(c{2,t+1})(-gamma)]. This function     returns the value of     (1 + r{tp1})*((c{2,t+1})(-gamma)) * pdf(A|mu,sigma)     for a given value of A and k2tp1\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_C-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_C","text":"get_C\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_Eul_err-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_Eul_err","text":"get_Eul_err\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_ExpMU_c2_b-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_ExpMU_c2_b","text":"get_ExpMU_c2_b\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_ExpMU_c2tp1_k-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_ExpMU_c2tp1_k","text":"get_ExpMU_c2tp1_k\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_Hbar_err-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_Hbar_err","text":"get_Hbar_err     This function is the error function that solves for the current     period shock that sets w * n1 + x1 - cmin - Kmin = Hbar. This is     the minimum shock that does not create default.\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_Ht-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_Ht","text":"get_Ht\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_MU_c2_pdf-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_MU_c2_pdf","text":"get_MU_c2_pdf \tThis function is the target for calculating the integral (expectation): E[(c{2,t+1})^(-gamma)].  \tThis function returns the value of ((c{2,t+1})^(-gamma)) * pdf(A|mu,sigma) for a given value of A and k2tp1\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_MUc_CRRA-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_MUc_CRRA","text":"get_MUc_CRRA\n\nGenerate marginal utility(ies) of consumption with CRRA consumption\nutility and stitched function at lower bound such that the new\nhybrid function is defined over all consumption on the real\nline but the function has similar properties to the Inada condition.\nu'(c) = c ** (-sigma) if c >= epsilon\n  \t      = g'(c) = 2 * b2 * c + b1 if c < epsilon\nsuch that g'(epsilon) = u'(epsilon)\nand g''(epsilon) = u''(epsilon)\nu(c) = (c ** (1 - sigma) - 1) / (1 - sigma)\ng(c) = b2 * (c ** 2) + b1 * c + b0\n\nINPUTS:\nc  = scalar, individual consumption in a particular period\ngamma = scalar >= 1, coefficient of relative risk aversion for CRRA\n      utility function: (c ^ (1-gamma) - 1) / (1 - gamma)\n\nOTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None\nOBJECTS CREATED WITHIN FUNCTION:\nepsilon    = scalar > 0, positive value close to zero\nc_s        = scalar, individual consumption\nc_s_cnstr  = boolean, =True if c_s < epsilon\nb1         = scalar, intercept value in linear marginal utility\nb2         = scalar, slope coefficient in linear marginal utility\nMU_c       = scalar or (p,) vector, marginal utility of consumption\n         or vector of marginal utilities of consumption\np          = integer >= 1, number of periods remaining in lifetime\ncvec_cnstr = (p,) boolean vector, =True for values of cvec < epsilon\n\nRETURNS: MU_c\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_Y-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_Y","text":"get_Y(k2t, zt, args)\n\nCalculate aggregate output\n\nINPUTS:\nKt   =\nLt   =\nzt   =\nargs =\nRETURNS: Yt\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_c1mgam-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_c1mgam","text":"get_c1mgam\n\nGenerate marginal utility(ies) of consumption with CRRA consumption\nutility and stitched function at lower bound such that the new\nhybrid function is defined over all consumption on the real\nline but the function has similar properties to the Inada condition.\nf(c) = c ** (1-sigma) if c >= epsilon\ng(c) = b2 * c + b1    if c < epsilon\n    such that g(epsilon) = f(epsilon)\n    and g'(epsilon) = f'(epsilon)\n    f(c) = c ** (1 - sigma)\n    g(c) = b2 * c + b1\n    s.t. b2 = (1 - gamma) * (epsilon ** (-gamma))\n         b1 = epsilon**(-gamma) - (1-gamma) * (epsilon ** (1-gamma))\n\nINPUTS:\nc  = scalar, individual consumption in a particular period\ngamma = scalar >= 1, coefficient of relative risk aversion for CRRA\n        utility function: (c**(1-gamma) - 1) / (1 - gamma)\n\nOTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None\nOBJECTS CREATED WITHIN FUNCTION:\nepsilon    = scalar > 0, positive value close to zero\nb1         = scalar, intercept value in linear marginal utility\nb2         = scalar, slope coefficient in linear marginal utility\nMU_c       = scalar or (p,) vector, marginal utility of consumption\n             or vector of marginal utilities of consumption\np          = integer >= 1, number of periods remaining in lifetime\ncvec_cnstr = (p,) boolean vector, =True for values of cvec < epsilon\n\nRETURNS: f_c\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_c2t-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_c2t","text":"get_c2t\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_c2tp1_1mgam_pdf-Tuple{Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_c2tp1_1mgam_pdf","text":"get_c2tp1_1mgam_pdf \tThis function is the target for calculating the integral (expectation): E[(c{2,t+1})^(1-gamma)].  \tThis function returns the value of ((c{2,t+1})^(1-gamma)) * pdf(A|mu,sigma) for a given value of A and k2tp1\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_k2tp1-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_k2tp1","text":"get_k2tp1\n\nSolve for k2tp1\nc1t + k2tp1 = wt * n1 - tau * w1 * n1\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_r-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_r","text":"get_r\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_w-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_w","text":"get_w\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.get_zstar-Tuple{Any, Any, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.get_zstar","text":"get_zstar\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.sim_timepath-NTuple{28, Any}","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.sim_timepath","text":"sim_timepath \n\nRuns the simulation\n\n\n\n\n\n","category":"method"},{"location":"#Evans2020.trunc_norm_draws","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Evans2020.trunc_norm_draws","text":"trunc_norm_draws\n\nDraw (N x S) matrix of random draws from a truncated normal\ndistribution based on a normal distribution with mean mu and\nstandard deviation sigma and cutoffs (cut_lb, cut_ub). These draws\ncorrespond to an (N x S) matrix of randomly generated draws from a\nuniform distribution U(0,1).\n\nINPUTS:\nunif_vals = (N, S) matrix, (N,) vector, or scalar in (0,1), random\n            draws from uniform U(0,1) distribution\nmu        = scalar, mean of the nontruncated normal distribution\n            from which the truncated normal is derived\nsigma     = scalar > 0, standard deviation of the nontruncated\n            normal distribution from which the truncated normal is\n            derived\ncut_lb    = scalar or string, ='None' if no lower bound cutoff is\n            given, otherwise is scalar lower bound value of\n            distribution. Values below this cutoff have zero\n            probability\ncut_ub    = scalar or string, ='None' if no upper bound cutoff is\n            given, otherwise is scalar lower bound value of\n            distribution. Values below this cutoff have zero\n            probability\nOTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:\n    scipy.stats.norm()\nOBJECTS CREATED WITHIN FUNCTION:\ncut_ub_cdf  = scalar in [0, 1], cdf of N(mu, sigma) at upper bound\n              cutoff of truncated normal distribution\ncut_lb_cdf  = scalar in [0, 1], cdf of N(mu, sigma) at lower bound\n              cutoff of truncated normal distribution\nunif2_vals  = (N, S) matrix, (N,) vector, or scalar in (0,1),\n              rescaled uniform derived from original.\ntnorm_draws = (N, S) matrix, (N,) vector, or scalar in (0,1),\n              values drawn from truncated normal PDF with base\n              normal distribution N(mu, sigma) and cutoffs\n              (cut_lb, cut_ub)\nFILES CREATED BY THIS FUNCTION: None\nRETURNS: tnorm_draws\n\n\n\n\n\n","category":"function"},{"location":"#Case-number-1-:-\\varepsilon-1-and-\\mu-is-constant","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Case number 1 : varepsilon = 1 and mu is constant","text":"","category":"section"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"We run a simulation aiming at capturing the effect on realized lifetime utility of a government transer program. We look at the difference between the baseline model when there is no government transer and a model where the transfer is 5 percent of average savings. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"In the case where varepsilon = 1, we have a Cobb-Douglas productivity function.  And mu, which capturates the riskiness of returns ER_t+1, is constant and equal to 1.0786.","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"We simulate 15 time series of 25 periods each and compute the average interest rates. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"julia> using Evans2020\n\njulia> include(\"FUNC_NPC.jl\")\n\n# Create OUTPUT directory if does not already exist\njulia>  cur_path = string(@__DIR__)\njulia>  output_fldr = \"OUTPUT\"\njulia>  output_dir = joinpath(cur_path, output_fldr)\njulia>  if !ispath(output_dir)\n         mkpath(output_dir)\n        end \n\n###\n#------------------------------------------------------------------------\n#Set exogenous parameters\n#------------------------------------------------------------------------\n#yrs_in_per = integer >= 1, number of years in a model period\n#beta_an    = scalar in (0, 1), annual discount factor\n#beta       = scalar in (0, 1), model period discount factor\n#gamma      = scalar >= 1, coefficient of relative risk aversion\n#c_min      = scalar > 0, minimum individual consumption\n#K_min      = scalar > 0, minimum aggregate capital stock\n#n_1        = scalar >= 0, exogenous labor supply when young\n#n_2        = scalar >= 0, exogenous labor supply when old\n#n_vec      = (2,) vector, lifetime exogenous labor supply\n#alpha      = scalar in (0, 1), capital share of income\n#delta_an   = scalar in (0, 1], annual depreciation rate\n#delta      = scalar in (0, 1], model period depreciation rate\n#rho_an     = scalar in (-1, 1), annual persistence of normally\n#             distributed TFP process\n#rho        = scalar in (-1, 1), model period persistence of normally\n#             distributed TFP process\n#mu         = scalar, unconditional mean of normally distributed TFP\n#             process\n#sigma_an   = scalar > 0, annual standard deviation of normally\n#             distributed TFP process\n#rho_sum    = scalar, recursive geometric sum of rho ** 2\n#y_ind      = integer >= 0, index of yrs_in_per\n#sigma      = scalar > 0, model period standard deviation of normally\n#             distributed TFP process\n#A_min      = scalar >= 0, minimum value in support of lognormally\n#             distributed TFP process\n#z_min      = scalar, minimum value in support of normally distributed\n#             TFP process\n#Hbar_vec   = (Hbar_size,) vector, values of Hbar\n#Hbar_size  = integer >= 1, number of values of Hbar\n#k20_vec    = (Hbar_size,) vector, values of k20\n#k20_size   = integer >= 1, number of values of k20_vec\n#z0         = scalar, initial normally distributed TFP value\n#T          = integer > 1, maximum number of periods to simulate\n#S          = integer >= 1, number of simulations\n#rand_seed  = integer > 0, random seed for simulation\n#------------------------------------------------------------------------\n#'''\n\njulia>  yrs_in_per = 25\njulia>  beta_an = 0.96\njulia>  beta = beta_an^yrs_in_per\njulia>  gamma = 2.2\njulia>  c_min = 1e-5\njulia>  K_min = 1e-5\n\n# Firm parameters\njulia>  alpha = 1/3\njulia>  epsilon = 1.0  # Inf\njulia>  delta_an = 0.0\njulia>  delta = 1 - ((1 - delta_an)^yrs_in_per)\njulia>  nvec = Array([1.0, 0.0])\n\n# Aggregate shock z parameters\njulia>  rho_an = 0.95\njulia>  rho = rho_an^yrs_in_per\njulia>  mu_an = 0.0\njulia>  sigma_an = 0.2  # 0.4946\njulia>  rho_sum = 0.0\njulia>  rho2_sum = 0.0\njulia>  for y_ind in range(0,stop = (yrs_in_per-1),step = 1)\n            rho_sum = rho_sum + rho_an^y_ind\n            rho2_sum = rho2_sum + rho_an^(2*y_ind)\n        end \njulia>  sigma = sqrt(rho2_sum*(sigma_an^2))\njulia>  mu = mu_an*rho_sum\njulia>  A_min = 0.0\njulia>  if A_min == 0.0\n             z_min = -Inf\n        elseif (A_min > 0.0) && (A_min < exp(mu))\n              z_min = log(A_min)\n        elseif A_min >= exp(mu)\n        print(\"Parameter Error: A_min >= e^(mu)\")\n        end\n        \n\n# Set government parameters, transfer parameters, and initial values\njulia>  Hbar_vec = Array([0.0, 0.05])\n# self.Hbar_vec = Array([0.0, 0.05, 0.11, 0.17])\njulia>  Hbar_size = length(Hbar_vec)\njulia>  Hbar = Hbar_vec[1]\njulia>  tau = nothing\njulia>  z0 = mu\n\n# Set simulation parameters\njulia>  T = 25\njulia>  S = 15\njulia>  rand_seed = 25\n\n# print(\"sigma\")\n# print(sigma)\n# print(\" \")\n# print(\"beta\")\n# print(beta)\n# print(\" \")\n\n\n\"\"\"\n------------------------------------------------------------------------\nCalibrate beta, mu, gamma\n------------------------------------------------------------------------\n\"\"\"\n\njulia>  avg_rtp1_size = 3\njulia>  avg_rtp1_an_vec = Array(range(0.00,stop = 0.04,length = avg_rtp1_size))\njulia>  avg_Rtp1_vec = (1 .+ avg_rtp1_an_vec).^yrs_in_per\njulia>  avg_rbart_size = 3\njulia>  avg_rbart_an_vec = Array(range(-0.02,stop = 0.01, length = avg_rbart_size))\njulia>  avg_Rbart_vec = (1 .+ avg_rbart_an_vec).^yrs_in_per\n\n# print(\"avg_Rtp1_vec\")\n# print(avg_Rtp1_vec)\n# print(\" \")\n# print(\"avg_Rbart_vec\")\n# print(avg_Rbart_vec)\n# print(\" \")\n\njulia>  avgRtp1_mat = repeat(reshape(avg_Rtp1_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  avgRbart_mat = repeat(reshape(avg_Rbart_vec,(1, avg_rbart_size)), avg_rtp1_size, 1)\njulia>  avgRtp1_gt_avgRbart = ((avgRtp1_mat - avgRbart_mat) .> 0) \n# print(avgRtp1_gt_avgRbart)\n\n# Calibrate mu using linear production expected MPK\njulia>  mu_vec = 1.0786 .* fill!(similar(avg_Rtp1_vec), 1)\n# mu_vec = log.(avg_Rtp1_vec) .- log(alpha) .- ((sigma^2) / 2)\njulia>  mu_mat = repeat(reshape(mu_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  mu_mat[.!avgRtp1_gt_avgRbart] .= NaN \n\n# Calibrate beta using Cobb-Douglas expected values expression for beta\njulia>  beta_vec = (alpha / (1 - alpha)) .* (1 ./ (2 * avg_Rtp1_vec)) \njulia>  beta_an_vec = beta_vec.^(1 / yrs_in_per)\njulia>  beta_mat = repeat(reshape(beta_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  beta_mat[.!avgRtp1_gt_avgRbart] .=  NaN\n\n# Calibrate gamma\njulia>  gamma_mat = ((log.(avgRtp1_mat) - log.(avgRbart_mat)) ./ (sigma^2))\njulia>  gamma_mat[.!avgRtp1_gt_avgRbart]  .=  NaN\n\n# Calibrate x_1\njulia>  x1_mat = (((1 - alpha) * exp.(mu_mat .+ ((sigma ^ 2) / 2)) .* ((2 * beta_mat) .^alpha)) .^ (1 / (1 - alpha)))\n\n# Calibrate kbar_2\njulia>  kbar2_mat = 2 .* beta_mat .* x1_mat\njulia>  Hbar_vec[2] = 0.05 * kbar2_mat[1, 1] # 1.0786\n# print(\"Hbar_vec = \", Hbar_vec)\n\n# Calibrate x_1 array for different values of x1, given calibration\njulia>  x1_mat2 = transpose(x1_mat)\njulia>  x1_arr = zeros(3, avg_rtp1_size, avg_rbart_size) \njulia>  x1_arr[:, 1, :] = x1_mat2 \njulia>  x1_arr[:, 2, :] = 0.5 .* x1_mat2\njulia>  x1_arr[:, 3, :] = 0.0 .* x1_mat2 \n\n# Calibrate sigma vector of 5% and 10% increases\njulia>  sigma_vec = zeros(3)\njulia>  sigma_vec[1] = sigma\njulia>  sigma_vec[2] = 1.05 * sigma\njulia>  sigma_vec[3] = 1.10 * sigma\n\n# Calibrate corresponding mu_arr that holds the expected value of the\n# TFP shock while expanding the variance. If ExpA is the expected value of\n# the TFP shock, then ExpA = exp.(mu .+ (sig^2) / 2), then\n# log.(ExpA) = mu .+ (sig^2) / 2\njulia>  ExpA = mu_mat .+ (sigma ^ 2) / 2\njulia>  mu_mat2 = transpose(mu_mat)\njulia>  mu_arr = zeros(3, avg_rtp1_size, avg_rbart_size)\njulia>  mu_arr[:, 1, :] = mu_mat2\njulia>  mu_arr[:, 2, :] = mu_mat2\njulia>  mu_arr[:, 3, :] = mu_mat2\n# mu_arr[:, :, 2] = ExpA .- (sigma_vec[2] ^ 2) / 2\n# mu_arr[:, :, 3] = ExpA .- (sigma_vec[3] ^ 2) / 2\n\n# print(\"mu_mat\")\n# print(mu_mat)\n# print(\" \")\n# print(\"beta_mat\")\n# print(beta_mat)\n# print(\" \")\n# print(\"gamma_mat\")\n# print(gamma_mat)\n# print(\" \")\n# print(\"x1_mat\")\n# print(x1_mat)\n# print(\" \")\n# print(\"kbar2_mat\")\n# print(kbar2_mat)\n# print(\" \")\n# print(\"x1_arr 1\")\n# print(x1_arr[:, :, 1])\n# print(\" \")\n# print(\"x1_arr 2\")\n# print(x1_arr[:, :, 2])\n# print(\" \")\n# print(\"x1_arr 3\")\n# print(x1_arr[:, :, 3])\n# print(\" \")\n# print(\"sigma_vec\")\n# print(sigma_vec)\n# print(\" \")\n# print(\"mu_arr 1\")\n# print(mu_arr[:, :, 1])\n# print(\" \")\n# print(\"mu_arr 2\")\n# print(mu_arr[:, :, 2])\n# print(\" \")\n# print(\"mu_arr 3\")\n# print(mu_arr[:, :, 3])\n# print(\" \")\n\njulia>  default_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  Random.seed!(rand_seed) \njulia>  unif_mat = rand(Uniform(0, 1), (S, T))\n\n# First three dimensions of zt_arr correspond to mu_arr in different order\njulia>  zt_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3)\n\njulia>  cut_lb = 0\njulia>  eps_t = 0\njulia>  z_t = 0\njulia>  z_tm1 = 0\n\njulia>  for sig_ind in range(1, stop=(3), step=1)\n            sigma = sigma_vec[sig_ind]\n             for avgrtp1_ind in range(1, stop=(avg_rtp1_size), step=1)\n                for avgrbart_ind in range(1, stop=(avg_rbart_size), step=1)\n                  mu = mu_arr[avgrbart_ind, sig_ind, avgrtp1_ind]\n                    for s_ind in range(1, stop=(S), step=1)\n                         for t_ind in range(1, stop=(T), step=1)\n                            unif = unif_mat[s_ind, t_ind]\n                                 if t_ind == 1 && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true\n                                    cut_lb = z_min - mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                    z_t = mu + eps_t\n                                 elseif ((t_ind > 1) && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true)\n                                    z_tm1 = zt_arr[s_ind, t_ind - 1, avgrbart_ind, avgrtp1_ind, sig_ind]\n                                    cut_lb = z_min - rho * z_tm1 - (1 - rho) * mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                     z_t = rho * z_tm1 + (1 - rho) * mu .+ eps_t \n                                  else\n                                      z_t = NaN\n                                  end\n                             zt_arr[s_ind, t_ind, avgrbart_ind,  avgrtp1_ind, sig_ind] = z_t  \n                           end \n                        end \n                     end \n                 end \n            end \n\njulia>  c1t_arr = zero(default_arr)\njulia>  c2t_arr = zero(default_arr)\njulia>  ut_arr = zeros(S, T - 1, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  Ht_arr = zero(default_arr)\njulia>  wt_arr = zero(default_arr)\njulia>  rt_arr = zero(default_arr)\njulia>  k2t_arr = zero(default_arr)\njulia>  rbart_arr = zero(default_arr)\njulia>  rbart_an_arr = zero(default_arr)\njulia>  EulErr_arr = zero(default_arr)\njulia>  PathTime_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  s_ind_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  for rtp1_ind in range(1, stop=(avg_rtp1_size), step=1) \n            for rbart_ind in range(1, stop=(avg_rbart_size), step=1) \n                 kbar2_mat2 = (!iszero).(kbar2_mat)\n                 k2t_arr[:, 1, rbart_ind, rtp1_ind, :, :, :] .=  kbar2_mat2[rtp1_ind, rbart_ind]\n            end\n        end\n\njulia>  mu_in = 0\njulia>  sigma_in = 0\njulia>  x1_in = 0\njulia>  z0_vec_in = 0\njulia>  gamma_in = 0\njulia>  beta_in = 0\njulia>  k20_in = 0\njulia>  simulations = 0\njulia>  H_ind = 1\njulia>  risk_type_ind = 1\njulia>  risk_val_ind = 1\njulia>  avgrtp1_ind = 1\njulia>  avgrbart_ind = 1\njulia>  timepaths_s = 0\njulia>  for H_ind in 1:Hbar_size\n            Hbar_in = Hbar_vec[H_ind]\n              for risk_type_ind in 1:2 #0=xval, 1=sigval\n                 for risk_val_ind in 1:3\n                        for avgrtp1_ind in 1:avg_rtp1_size\n                          for avgrbart_ind in 1:avg_rbart_size\n                             if avgRtp1_gt_avgRbart[avgrtp1_ind, avgrbart_ind]\n                                   simulations = []\n                                   beta_in = beta_mat[avgrtp1_ind, avgrbart_ind]\n                                   gamma_in = gamma_mat[avgrtp1_ind, avgrbart_ind]\n                                   k20_in = kbar2_mat[avgrtp1_ind, avgrbart_ind]\n                                  if risk_type_ind == 1\n                                        mu_in = mu_mat[avgrtp1_ind, avgrbart_ind]\n                                        sigma_in = sigma_vec[1]\n                                        x1_in = x1_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                        z0_vec_in = zt_arr[:, 1, avgrbart_ind, avgrtp1_ind, 1]\n                                   elseif risk_type_ind == 2 \n                                         mu_in = mu_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                         sigma_in = sigma_vec[risk_val_ind]\n                                         x1_in = x1_mat[avgrtp1_ind, avgrbart_ind]\n                                         z0_vec_in = zt_arr[ :, 1, avgrbart_ind, avgrtp1_ind, risk_val_ind,]\n                                    end\n\n                                    for s_ind in 1:S\n                                       z0_in = z0_vec_in[s_ind]\n                                        if risk_type_ind == 1\n                                                zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, 1]\n                                        elseif risk_type_ind == 2\n                                            zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_type_ind,]\n                                        end\n                                     timepaths_s = sim_timepath(\n                                         Hbar_in, beta_in, gamma_in, k20_in,\n                                         sigma_in, x1_in, T, z0_in, z_min, rho,\n                                          mu_in, nvec, epsilon, alpha, delta, tau,\n                                          c_min, K_min, A_min, yrs_in_per,\n                                          H_ind,\n                                          risk_type_ind,\n                                          risk_val_ind,\n                                          avgrtp1_ind,\n                                          avgrbart_ind, s_ind,\n                                          zt_vec_in,\n                                          rand_seed)\n                                     push!(simulations, timepaths_s)\n                                  end\n                        \n                        for s_ind in 1:S\n                            s_ind_arr[avgrbart_ind, s_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][6] # original S_ind\n                            default_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][8]  # default_vec\n                            c1t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][9])  # c1t_vec\n                            c2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][10])  # c2t_vec\n                            ut_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][11]  # ut_vec\n                            Ht_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][12])  # Ht_vec\n                            wt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][13])  # wt_vec\n                            rt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][14])  # rt_vec\n                            pop!(simulations[s_ind][15])\n                            k2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][15])  #        k2t_vec[:-1]\n                            rbart_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][16])  # rbart_vec\n                            rbart_an_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][17])  # rbart_an_vec\n                            EulErr_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][18])  # EulErr_vec\n                        end\n\n                    else  # avg_Rtp1 <= avg_rbart\n                        s_ind_arr[avgrbart_ind, :, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN \n                        default_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # default_vec\n                        c1t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c1t_vec\n                        c2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c2t_vec\n                        ut_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # ut_vec\n                        Ht_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # Ht_vec\n                        wt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # wt_vec\n                        rt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rt_vec\n                        k2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # k2t_vec[:-1]\n                        rbart_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rbart_vec\n                        rbart_an_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # rbart_an_vec\n                        EulErr_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # EulErr_vec\n                    end\n                end\n\n            dict_endog_new = Dict(\n                \"unif_mat\" => unif_mat,\n                \"zt_arr\" => zt_arr ,\n                \"c1t_arr\" => c1t_arr,\n                \"c2t_arr\"=> c2t_arr,\n                \"ut_arr\" => ut_arr,\n                \"Ht_arr\" => Ht_arr,\n                \"wt_arr\" => wt_arr,\n                \"rt_arr\" => rt_arr,\n                \"rbart_arr\" => rbart_arr,\n                \"rbart_an_arr\" => rbart_an_arr,\n                \"k2t_arr\" => k2t_arr,\n                \"EulErr_arr\" => EulErr_arr,\n                \"default_arr\" => default_arr,\n                \"s_ind_arr\" => s_ind_arr)\n                  \n            save(\"dict_endog_$(H_ind)$(risk_type_ind)$(risk_val_ind).jld2\", dict_endog_new)\n\n            end\n        end\n    end\nend\n\n\njulia> default_p1 = default_arr\njulia> default_p1[:, 1, :, :, :, :, :] = zeros(S, 1, 3, 3, 3, 2, 2)\n\njulia> zt_arr_macro = repeat(reshape(zt_arr,(S, T, avg_rbart_size, avg_rtp1_size, 3, 1, 1)), 1, 1, 1, 1, 1, Hbar_size, 2)\n\njulia> Kt_arr = (1 .- default_p1) .* k2t_arr\njulia> Y_args = (nvec, epsilon, alpha)\njulia> Yt_arr = (1 .- default_p1) .* get_Y(Kt_arr, zt_arr_macro, Y_args)\njulia> Ct_arr = (1 .- default_p1) .* get_C(c1t_arr, c2t_arr)\n\njulia> dict_params = Dict(\n        \"yrs_in_per\" => yrs_in_per,\n        \"beta_an\" => beta_an,\n        \"beta\" => beta,\n        \"gamma\" => gamma,\n        \"c_min\" => c_min,\n        \"K_min\" => K_min,\n        \"nvec\" => nvec,\n        \"n1\" => nvec[1],\n        \"n2\" => nvec[2],\n        \"alpha\" => alpha,\n        \"epsilon\" => epsilon,\n        \"delta_an\" => delta_an,\n        \"delta\" => delta,\n        \"rho_an\" => rho_an,\n        \"rho\" => rho,\n        \"mu_an\" => mu_an,\n        \"sigma_an\" => sigma_an,\n        \"sigma\" => sigma,\n        \"mu\" => mu,\n        \"A_min\" => A_min,\n        \"z_min\" => z_min,\n        \"Hbar_vec\" => Hbar_vec,\n        \"Hbar_size\" => Hbar_size,\n        \"Hbar\" => Hbar,\n        \"tau\" => tau,\n        \"T\" => T,\n        \"S\" => S,\n        \"rand_seed\" => rand_seed,\n        \"max_cores\" => max_cores,\n        \"num_workers\" => num_workers,\n        \"avg_rtp1_size\" => avg_rtp1_size,\n        \"avg_rtp1_an_vec\" => avg_rtp1_an_vec,\n        \"avg_Rtp1_vec\" => avg_Rtp1_vec,\n        \"avg_rbart_size\" => avg_rbart_size,\n        \"avg_rbart_an_vec\" => avg_rbart_an_vec,\n        \"avg_Rbart_vec\" => avg_Rbart_vec,\n        \"avgRtp1_mat\" => avgRtp1_mat,\n        \"avgRbart_mat\" => avgRbart_mat,\n        \"avgRtp1_gt_avgRbart\" => avgRtp1_gt_avgRbart,\n        \"mu_vec\" => mu_vec,\n        \"mu_mat\" => mu_mat,\n        \"mu_arr\" => mu_arr,\n        \"beta_vec\" => beta_vec,\n        \"beta_mat\" => beta_mat,\n        \"gamma_mat\" => gamma_mat,\n        \"x1_mat\" => x1_mat,\n        \"x1_arr\" => x1_arr,\n        \"kbar2_mat\" => kbar2_mat,\n        \"sigma_vec\" => sigma_vec,\n        \"ExpA\" => ExpA)\n\njulia> dict_endog = Dict(\n        \"unif_mat\" => unif_mat,\n        \"zt_arr\" => zt_arr ,\n        \"c1t_arr\" =>  c1t_arr,\n        \"c2t_arr\"=>  c2t_arr,\n        \"ut_arr\" =>  ut_arr,\n        \"Ht_arr\" =>  Ht_arr,\n        \"wt_arr\" =>  wt_arr,\n        \"rt_arr\" =>  rt_arr,\n        \"rbart_arr\" =>  rbart_arr,\n        \"rbart_an_arr\" => rbart_an_arr,\n        \"k2t_arr\" =>  k2t_arr,\n        \"EulErr_arr\" =>  EulErr_arr,\n        \"Kt_arr\" => Kt_arr,\n        \"Yt_arr\"=> Yt_arr,\n        \"Ct_arr\" => Ct_arr,\n        \"default_arr\" =>  default_arr,\n        \"s_ind_arr\" =>  s_ind_arr)\n\nresults_sims = Dict(\"dict_params\" => dict_params, \"dict_endog\" => dict_endog)\nsave(\"results_sims.jld2\", results_sims)","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"To produce the output from the simulations we then run the following code : ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"julia>  cd(\"-\")\njulia>  cur_dir = string(@__DIR__)\njulia>  output_dir = joinpath(cur_dir, \"OUTPUT\") \n\n\n# Load pickled results\njulia> for H_ind in range(1, stop=2, step=1) \n    for risk_type_ind in range(1, stop=2, step=1) \n        for risk_val_ind in range(1, stop=3, step=1)     \n            global h = H_ind\n            global r1  =  risk_type_ind\n            global r2 = risk_val_ind\n            println(\"dict_endog_$h$r1$r2\")\n            global ut_arr = load(\"dict_endog_$h$r1$r2.jld2\", \"ut_arr\") \n            eval(Meta.parse(\"ut_arr_$h$r1$r2 = ut_arr[ :, :, :, :, r2, r1, h]\")) \n            println(\"ut_arr_$h$r1$r2\")\n            global rbart_an_arr = load(\"dict_endog_$h$r1$r2.jld2\", \"rbart_an_arr\") \n            eval(Meta.parse(\"rbart_an_arr_$h$r1$r2 = rbart_an_arr[ :, :, :, :, r2, r1, h]\"))                  \n         end\n     end\n end\n\n# Solve for percent difference in average welfare matrices\njulia> avg_rtp1_size = 3\njulia> avg_rbart_size = 3\n\n#Generate Paper Table 2\njulia> for risk_type_ind in range(1, stop=2, step=1)\n  for risk_val_ind in range(1, stop=3, step=1)\n     global r1 = risk_type_ind  \n     global r2 = risk_val_ind\n     eval(Meta.parse(\"ut_pctdif_1$r1$r2 = zeros((avg_rbart_size, avg_rtp1_size))\"))\n     for avgrtp1_ind in 1:3 \n       for avgrbart_ind in 1:3\n         global t = avgrtp1_ind\n         global b = avgrbart_ind \n         eval(Meta.parse(\"ut_mat_1$r1$r2 = ut_arr_1$r1$r2[ :, :, $b, $t]\"))\n         eval(Meta.parse(\"ut_mat_2$r1$r2 = ut_arr_2$r1$r2[ :, :, $b, $t]\"))\n         eval(Meta.parse(\"avg_ut_1$r1$r2 = mean(ut_mat_1$r1$r2[.!isnan.(ut_mat_1$r1$r2)])\")) \n         eval(Meta.parse(\"avg_ut_2$r1$r2 = mean(ut_mat_2$r1$r2[.!isnan.(ut_mat_2$r1$r2)])\")) \n         eval(Meta.parse(\"ut_pctdif_1$r1$r2[b, t] = (avg_ut_2$r1$r2 - avg_ut_1$r1$r2)/avg_ut_1$r1$r2\")) \n        end\n      end\n      println(\"ut_pctdif_1$r1$r2 for Cobb-Douglas, mu variable\")\n      eval(Meta.parse(\"println(transpose(ut_pctdif_1$r1$r2))\")) \n      println()\n   end\nend\n","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"The code gives us the following output, which we compare with the original output from the paper : ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"(Image: Table1)","category":"page"},{"location":"#Case-number-2-:-\\varepsilon-\\infty-and-\\mu-is-constant","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Case number 2 : varepsilon = infty and mu is constant","text":"","category":"section"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"In the case where varepsilon = infty we have a linear productivity function  Here mu is still constant and equal to 1.0786. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"Similarly, we run a simualtion of 15 times series with 25 periods each. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"julia> using Evans2020\n\njulia> include(\"FUNC_NPC.jl\")\n\n# Create OUTPUT directory if does not already exist\njulia>  cur_path = string(@__DIR__)\njulia>  output_fldr = \"OUTPUT\"\njulia>  output_dir = joinpath(cur_path, output_fldr)\njulia>  if !ispath(output_dir)\n         mkpath(output_dir)\n        end \n\n###\n#------------------------------------------------------------------------\n#Set exogenous parameters\n#------------------------------------------------------------------------\n#yrs_in_per = integer >= 1, number of years in a model period\n#beta_an    = scalar in (0, 1), annual discount factor\n#beta       = scalar in (0, 1), model period discount factor\n#gamma      = scalar >= 1, coefficient of relative risk aversion\n#c_min      = scalar > 0, minimum individual consumption\n#K_min      = scalar > 0, minimum aggregate capital stock\n#n_1        = scalar >= 0, exogenous labor supply when young\n#n_2        = scalar >= 0, exogenous labor supply when old\n#n_vec      = (2,) vector, lifetime exogenous labor supply\n#alpha      = scalar in (0, 1), capital share of income\n#delta_an   = scalar in (0, 1], annual depreciation rate\n#delta      = scalar in (0, 1], model period depreciation rate\n#rho_an     = scalar in (-1, 1), annual persistence of normally\n#             distributed TFP process\n#rho        = scalar in (-1, 1), model period persistence of normally\n#             distributed TFP process\n#mu         = scalar, unconditional mean of normally distributed TFP\n#             process\n#sigma_an   = scalar > 0, annual standard deviation of normally\n#             distributed TFP process\n#rho_sum    = scalar, recursive geometric sum of rho ** 2\n#y_ind      = integer >= 0, index of yrs_in_per\n#sigma      = scalar > 0, model period standard deviation of normally\n#             distributed TFP process\n#A_min      = scalar >= 0, minimum value in support of lognormally\n#             distributed TFP process\n#z_min      = scalar, minimum value in support of normally distributed\n#             TFP process\n#Hbar_vec   = (Hbar_size,) vector, values of Hbar\n#Hbar_size  = integer >= 1, number of values of Hbar\n#k20_vec    = (Hbar_size,) vector, values of k20\n#k20_size   = integer >= 1, number of values of k20_vec\n#z0         = scalar, initial normally distributed TFP value\n#T          = integer > 1, maximum number of periods to simulate\n#S          = integer >= 1, number of simulations\n#rand_seed  = integer > 0, random seed for simulation\n#------------------------------------------------------------------------\n#'''\n\njulia>  yrs_in_per = 25\njulia>  beta_an = 0.96\njulia>  beta = beta_an^yrs_in_per\njulia>  gamma = 2.2\njulia>  c_min = 1e-5\njulia>  K_min = 1e-5\n\n# Firm parameters\njulia>  alpha = 1/3\njulia>  epsilon = Inf\njulia>  delta_an = 0.0\njulia>  delta = 1 - ((1 - delta_an)^yrs_in_per)\njulia>  nvec = Array([1.0, 0.0])\n\n# Aggregate shock z parameters\njulia>  rho_an = 0.95\njulia>  rho = rho_an^yrs_in_per\njulia>  mu_an = 0.0\njulia>  sigma_an = 0.2  # 0.4946\njulia>  rho_sum = 0.0\njulia>  rho2_sum = 0.0\njulia>  for y_ind in range(0,stop = (yrs_in_per-1),step = 1)\n            rho_sum = rho_sum + rho_an^y_ind\n            rho2_sum = rho2_sum + rho_an^(2*y_ind)\n        end \njulia>  sigma = sqrt(rho2_sum*(sigma_an^2))\njulia>  mu = mu_an*rho_sum\njulia>  A_min = 0.0\njulia>  if A_min == 0.0\n             z_min = -Inf\n        elseif (A_min > 0.0) && (A_min < exp(mu))\n              z_min = log(A_min)\n        elseif A_min >= exp(mu)\n        print(\"Parameter Error: A_min >= e^(mu)\")\n        end\n        \n\n# Set government parameters, transfer parameters, and initial values\njulia>  Hbar_vec = Array([0.0, 0.05])\n# self.Hbar_vec = Array([0.0, 0.05, 0.11, 0.17])\njulia>  Hbar_size = length(Hbar_vec)\njulia>  Hbar = Hbar_vec[1]\njulia>  tau = nothing\njulia>  z0 = mu\n\n# Set simulation parameters\njulia>  T = 25\njulia>  S = 15\njulia>  rand_seed = 25\n\n# print(\"sigma\")\n# print(sigma)\n# print(\" \")\n# print(\"beta\")\n# print(beta)\n# print(\" \")\n\n\n\"\"\"\n------------------------------------------------------------------------\nCalibrate beta, mu, gamma\n------------------------------------------------------------------------\n\"\"\"\n\njulia>  avg_rtp1_size = 3\njulia>  avg_rtp1_an_vec = Array(range(0.00,stop = 0.04,length = avg_rtp1_size))\njulia>  avg_Rtp1_vec = (1 .+ avg_rtp1_an_vec).^yrs_in_per\njulia>  avg_rbart_size = 3\njulia>  avg_rbart_an_vec = Array(range(-0.02,stop = 0.01, length = avg_rbart_size))\njulia>  avg_Rbart_vec = (1 .+ avg_rbart_an_vec).^yrs_in_per\n\n# print(\"avg_Rtp1_vec\")\n# print(avg_Rtp1_vec)\n# print(\" \")\n# print(\"avg_Rbart_vec\")\n# print(avg_Rbart_vec)\n# print(\" \")\n\njulia>  avgRtp1_mat = repeat(reshape(avg_Rtp1_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  avgRbart_mat = repeat(reshape(avg_Rbart_vec,(1, avg_rbart_size)), avg_rtp1_size, 1)\njulia>  avgRtp1_gt_avgRbart = ((avgRtp1_mat - avgRbart_mat) .> 0) \n# print(avgRtp1_gt_avgRbart)\n\n# Calibrate mu using linear production expected MPK\njulia>  mu_vec = 1.0786 .* fill!(similar(avg_Rtp1_vec), 1)\n# mu_vec = log.(avg_Rtp1_vec) .- log(alpha) .- ((sigma^2) / 2)\njulia>  mu_mat = repeat(reshape(mu_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  mu_mat[.!avgRtp1_gt_avgRbart] .= NaN \n\n# Calibrate beta using Cobb-Douglas expected values expression for beta\njulia>  beta_vec = (alpha / (1 - alpha)) .* (1 ./ (2 * avg_Rtp1_vec)) \njulia>  beta_an_vec = beta_vec.^(1 / yrs_in_per)\njulia>  beta_mat = repeat(reshape(beta_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  beta_mat[.!avgRtp1_gt_avgRbart] .=  NaN\n\n# Calibrate gamma\njulia>  gamma_mat = ((log.(avgRtp1_mat) - log.(avgRbart_mat)) ./ (sigma^2))\njulia>  gamma_mat[.!avgRtp1_gt_avgRbart]  .=  NaN\n\n# Calibrate x_1\njulia>  x1_mat = (((1 - alpha) * exp.(mu_mat .+ ((sigma ^ 2) / 2)) .* ((2 * beta_mat) .^alpha)) .^ (1 / (1 - alpha)))\n\n# Calibrate kbar_2\njulia>  kbar2_mat = 2 .* beta_mat .* x1_mat\njulia>  Hbar_vec[2] = 0.05 * kbar2_mat[1, 1] # 1.0786\n# print(\"Hbar_vec = \", Hbar_vec)\n\n# Calibrate x_1 array for different values of x1, given calibration\njulia>  x1_mat2 = transpose(x1_mat)\njulia>  x1_arr = zeros(3, avg_rtp1_size, avg_rbart_size) \njulia>  x1_arr[:, 1, :] = x1_mat2 \njulia>  x1_arr[:, 2, :] = 0.5 .* x1_mat2\njulia>  x1_arr[:, 3, :] = 0.0 .* x1_mat2 \n\n# Calibrate sigma vector of 5% and 10% increases\njulia>  sigma_vec = zeros(3)\njulia>  sigma_vec[1] = sigma\njulia>  sigma_vec[2] = 1.05 * sigma\njulia>  sigma_vec[3] = 1.10 * sigma\n\n# Calibrate corresponding mu_arr that holds the expected value of the\n# TFP shock while expanding the variance. If ExpA is the expected value of\n# the TFP shock, then ExpA = exp.(mu .+ (sig^2) / 2), then\n# log.(ExpA) = mu .+ (sig^2) / 2\njulia>  ExpA = mu_mat .+ (sigma ^ 2) / 2\njulia>  mu_mat2 = transpose(mu_mat)\njulia>  mu_arr = zeros(3, avg_rtp1_size, avg_rbart_size)\njulia>  mu_arr[:, 1, :] = mu_mat2\njulia>  mu_arr[:, 2, :] = mu_mat2\njulia>  mu_arr[:, 3, :] = mu_mat2\n# mu_arr[:, :, 2] = ExpA .- (sigma_vec[2] ^ 2) / 2\n# mu_arr[:, :, 3] = ExpA .- (sigma_vec[3] ^ 2) / 2\n\n# print(\"mu_mat\")\n# print(mu_mat)\n# print(\" \")\n# print(\"beta_mat\")\n# print(beta_mat)\n# print(\" \")\n# print(\"gamma_mat\")\n# print(gamma_mat)\n# print(\" \")\n# print(\"x1_mat\")\n# print(x1_mat)\n# print(\" \")\n# print(\"kbar2_mat\")\n# print(kbar2_mat)\n# print(\" \")\n# print(\"x1_arr 1\")\n# print(x1_arr[:, :, 1])\n# print(\" \")\n# print(\"x1_arr 2\")\n# print(x1_arr[:, :, 2])\n# print(\" \")\n# print(\"x1_arr 3\")\n# print(x1_arr[:, :, 3])\n# print(\" \")\n# print(\"sigma_vec\")\n# print(sigma_vec)\n# print(\" \")\n# print(\"mu_arr 1\")\n# print(mu_arr[:, :, 1])\n# print(\" \")\n# print(\"mu_arr 2\")\n# print(mu_arr[:, :, 2])\n# print(\" \")\n# print(\"mu_arr 3\")\n# print(mu_arr[:, :, 3])\n# print(\" \")\n\njulia>  default_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  Random.seed!(rand_seed) \njulia>  unif_mat = rand(Uniform(0, 1), (S, T))\n\n# First three dimensions of zt_arr correspond to mu_arr in different order\njulia>  zt_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3)\n\njulia>  cut_lb = 0\njulia>  eps_t = 0\njulia>  z_t = 0\njulia>  z_tm1 = 0\n\njulia>  for sig_ind in range(1, stop=(3), step=1)\n            sigma = sigma_vec[sig_ind]\n             for avgrtp1_ind in range(1, stop=(avg_rtp1_size), step=1)\n                for avgrbart_ind in range(1, stop=(avg_rbart_size), step=1)\n                  mu = mu_arr[avgrbart_ind, sig_ind, avgrtp1_ind]\n                    for s_ind in range(1, stop=(S), step=1)\n                         for t_ind in range(1, stop=(T), step=1)\n                            unif = unif_mat[s_ind, t_ind]\n                                 if t_ind == 1 && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true\n                                    cut_lb = z_min - mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                    z_t = mu + eps_t\n                                 elseif ((t_ind > 1) && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true)\n                                    z_tm1 = zt_arr[s_ind, t_ind - 1, avgrbart_ind, avgrtp1_ind, sig_ind]\n                                    cut_lb = z_min - rho * z_tm1 - (1 - rho) * mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                     z_t = rho * z_tm1 + (1 - rho) * mu .+ eps_t \n                                  else\n                                      z_t = NaN\n                                  end\n                             zt_arr[s_ind, t_ind, avgrbart_ind,  avgrtp1_ind, sig_ind] = z_t  \n                           end \n                        end \n                     end \n                 end \n            end \n\njulia>  c1t_arr = zero(default_arr)\njulia>  c2t_arr = zero(default_arr)\njulia>  ut_arr = zeros(S, T - 1, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  Ht_arr = zero(default_arr)\njulia>  wt_arr = zero(default_arr)\njulia>  rt_arr = zero(default_arr)\njulia>  k2t_arr = zero(default_arr)\njulia>  rbart_arr = zero(default_arr)\njulia>  rbart_an_arr = zero(default_arr)\njulia>  EulErr_arr = zero(default_arr)\njulia>  PathTime_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  s_ind_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  for rtp1_ind in range(1, stop=(avg_rtp1_size), step=1) \n            for rbart_ind in range(1, stop=(avg_rbart_size), step=1) \n                 kbar2_mat2 = (!iszero).(kbar2_mat)\n                 k2t_arr[:, 1, rbart_ind, rtp1_ind, :, :, :] .=  kbar2_mat2[rtp1_ind, rbart_ind]\n            end\n        end\n\njulia>  mu_in = 0\njulia>  sigma_in = 0\njulia>  x1_in = 0\njulia>  z0_vec_in = 0\njulia>  gamma_in = 0\njulia>  beta_in = 0\njulia>  k20_in = 0\njulia>  simulations = 0\njulia>  H_ind = 1\njulia>  risk_type_ind = 1\njulia>  risk_val_ind = 1\njulia>  avgrtp1_ind = 1\njulia>  avgrbart_ind = 1\njulia>  timepaths_s = 0\njulia>  for H_ind in 1:Hbar_size\n            Hbar_in = Hbar_vec[H_ind]\n              for risk_type_ind in 1:2 #0=xval, 1=sigval\n                 for risk_val_ind in 1:3\n                        for avgrtp1_ind in 1:avg_rtp1_size\n                          for avgrbart_ind in 1:avg_rbart_size\n                             if avgRtp1_gt_avgRbart[avgrtp1_ind, avgrbart_ind]\n                                   simulations = []\n                                   beta_in = beta_mat[avgrtp1_ind, avgrbart_ind]\n                                   gamma_in = gamma_mat[avgrtp1_ind, avgrbart_ind]\n                                   k20_in = kbar2_mat[avgrtp1_ind, avgrbart_ind]\n                                  if risk_type_ind == 1\n                                        mu_in = mu_mat[avgrtp1_ind, avgrbart_ind]\n                                        sigma_in = sigma_vec[1]\n                                        x1_in = x1_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                        z0_vec_in = zt_arr[:, 1, avgrbart_ind, avgrtp1_ind, 1]\n                                   elseif risk_type_ind == 2 \n                                         mu_in = mu_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                         sigma_in = sigma_vec[risk_val_ind]\n                                         x1_in = x1_mat[avgrtp1_ind, avgrbart_ind]\n                                         z0_vec_in = zt_arr[ :, 1, avgrbart_ind, avgrtp1_ind, risk_val_ind,]\n                                    end\n\n                                    for s_ind in 1:S\n                                       z0_in = z0_vec_in[s_ind]\n                                        if risk_type_ind == 1\n                                                zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, 1]\n                                        elseif risk_type_ind == 2\n                                            zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_type_ind,]\n                                        end\n                                     timepaths_s = sim_timepath(\n                                         Hbar_in, beta_in, gamma_in, k20_in,\n                                         sigma_in, x1_in, T, z0_in, z_min, rho,\n                                          mu_in, nvec, epsilon, alpha, delta, tau,\n                                          c_min, K_min, A_min, yrs_in_per,\n                                          H_ind,\n                                          risk_type_ind,\n                                          risk_val_ind,\n                                          avgrtp1_ind,\n                                          avgrbart_ind, s_ind,\n                                          zt_vec_in,\n                                          rand_seed)\n                                     push!(simulations, timepaths_s)\n                                  end\n                        \n                        for s_ind in 1:S\n                            s_ind_arr[avgrbart_ind, s_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][6] # original S_ind\n                            default_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][8]  # default_vec\n                            c1t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][9])  # c1t_vec\n                            c2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][10])  # c2t_vec\n                            ut_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][11]  # ut_vec\n                            Ht_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][12])  # Ht_vec\n                            wt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][13])  # wt_vec\n                            rt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][14])  # rt_vec\n                            pop!(simulations[s_ind][15])\n                            k2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][15])  #        k2t_vec[:-1]\n                            rbart_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][16])  # rbart_vec\n                            rbart_an_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][17])  # rbart_an_vec\n                            EulErr_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][18])  # EulErr_vec\n                        end\n\n                    else  # avg_Rtp1 <= avg_rbart\n                        s_ind_arr[avgrbart_ind, :, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN \n                        default_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # default_vec\n                        c1t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c1t_vec\n                        c2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c2t_vec\n                        ut_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # ut_vec\n                        Ht_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # Ht_vec\n                        wt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # wt_vec\n                        rt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rt_vec\n                        k2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # k2t_vec[:-1]\n                        rbart_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rbart_vec\n                        rbart_an_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # rbart_an_vec\n                        EulErr_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # EulErr_vec\n                    end\n                end\n\n            dict_endog_new = Dict(\n                \"unif_mat\" => unif_mat,\n                \"zt_arr\" => zt_arr ,\n                \"c1t_arr\" => c1t_arr,\n                \"c2t_arr\"=> c2t_arr,\n                \"ut_arr\" => ut_arr,\n                \"Ht_arr\" => Ht_arr,\n                \"wt_arr\" => wt_arr,\n                \"rt_arr\" => rt_arr,\n                \"rbart_arr\" => rbart_arr,\n                \"rbart_an_arr\" => rbart_an_arr,\n                \"k2t_arr\" => k2t_arr,\n                \"EulErr_arr\" => EulErr_arr,\n                \"default_arr\" => default_arr,\n                \"s_ind_arr\" => s_ind_arr)\n                  \n            save(\"dict_endog_$(H_ind)$(risk_type_ind)$(risk_val_ind).jld2\", dict_endog_new)\n\n            end\n        end\n    end\nend\n\n\njulia> default_p1 = default_arr\njulia> default_p1[:, 1, :, :, :, :, :] = zeros(S, 1, 3, 3, 3, 2, 2)\n\njulia> zt_arr_macro = repeat(reshape(zt_arr,(S, T, avg_rbart_size, avg_rtp1_size, 3, 1, 1)), 1, 1, 1, 1, 1, Hbar_size, 2)\n\njulia> Kt_arr = (1 .- default_p1) .* k2t_arr\njulia> Y_args = (nvec, epsilon, alpha)\njulia> Yt_arr = (1 .- default_p1) .* get_Y(Kt_arr, zt_arr_macro, Y_args)\njulia> Ct_arr = (1 .- default_p1) .* get_C(c1t_arr, c2t_arr)\n\njulia> dict_params = Dict(\n        \"yrs_in_per\" => yrs_in_per,\n        \"beta_an\" => beta_an,\n        \"beta\" => beta,\n        \"gamma\" => gamma,\n        \"c_min\" => c_min,\n        \"K_min\" => K_min,\n        \"nvec\" => nvec,\n        \"n1\" => nvec[1],\n        \"n2\" => nvec[2],\n        \"alpha\" => alpha,\n        \"epsilon\" => epsilon,\n        \"delta_an\" => delta_an,\n        \"delta\" => delta,\n        \"rho_an\" => rho_an,\n        \"rho\" => rho,\n        \"mu_an\" => mu_an,\n        \"sigma_an\" => sigma_an,\n        \"sigma\" => sigma,\n        \"mu\" => mu,\n        \"A_min\" => A_min,\n        \"z_min\" => z_min,\n        \"Hbar_vec\" => Hbar_vec,\n        \"Hbar_size\" => Hbar_size,\n        \"Hbar\" => Hbar,\n        \"tau\" => tau,\n        \"T\" => T,\n        \"S\" => S,\n        \"rand_seed\" => rand_seed,\n        \"max_cores\" => max_cores,\n        \"num_workers\" => num_workers,\n        \"avg_rtp1_size\" => avg_rtp1_size,\n        \"avg_rtp1_an_vec\" => avg_rtp1_an_vec,\n        \"avg_Rtp1_vec\" => avg_Rtp1_vec,\n        \"avg_rbart_size\" => avg_rbart_size,\n        \"avg_rbart_an_vec\" => avg_rbart_an_vec,\n        \"avg_Rbart_vec\" => avg_Rbart_vec,\n        \"avgRtp1_mat\" => avgRtp1_mat,\n        \"avgRbart_mat\" => avgRbart_mat,\n        \"avgRtp1_gt_avgRbart\" => avgRtp1_gt_avgRbart,\n        \"mu_vec\" => mu_vec,\n        \"mu_mat\" => mu_mat,\n        \"mu_arr\" => mu_arr,\n        \"beta_vec\" => beta_vec,\n        \"beta_mat\" => beta_mat,\n        \"gamma_mat\" => gamma_mat,\n        \"x1_mat\" => x1_mat,\n        \"x1_arr\" => x1_arr,\n        \"kbar2_mat\" => kbar2_mat,\n        \"sigma_vec\" => sigma_vec,\n        \"ExpA\" => ExpA)\n\njulia> dict_endog = Dict(\n        \"unif_mat\" => unif_mat,\n        \"zt_arr\" => zt_arr ,\n        \"c1t_arr\" =>  c1t_arr,\n        \"c2t_arr\"=>  c2t_arr,\n        \"ut_arr\" =>  ut_arr,\n        \"Ht_arr\" =>  Ht_arr,\n        \"wt_arr\" =>  wt_arr,\n        \"rt_arr\" =>  rt_arr,\n        \"rbart_arr\" =>  rbart_arr,\n        \"rbart_an_arr\" => rbart_an_arr,\n        \"k2t_arr\" =>  k2t_arr,\n        \"EulErr_arr\" =>  EulErr_arr,\n        \"Kt_arr\" => Kt_arr,\n        \"Yt_arr\"=> Yt_arr,\n        \"Ct_arr\" => Ct_arr,\n        \"default_arr\" =>  default_arr,\n        \"s_ind_arr\" =>  s_ind_arr)\n\nresults_sims = Dict(\"dict_params\" => dict_params, \"dict_endog\" => dict_endog)\nsave(\"results_sims.jld2\", results_sims)","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"We run the preivous code to produce the tables. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"This simulation give us the following output, once again compared with the original output : ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"(Image: Table3)","category":"page"},{"location":"#Case-number-3-:-\\varepsilon-1-and-\\mu-is-a-function-of-:E[R_{t1}]","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Case number 3 : varepsilon = 1 and mu is a function of E[R_{t+1}]","text":"","category":"section"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"For this case, we have a Cobb-Douglas production function but now the risk parameter mu is a function of expected interest rates and thus is not constant anymore. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"julia> using Evans2020\n\njulia> include(\"FUNC_NPC.jl\")\n\n# Create OUTPUT directory if does not already exist\njulia>  cur_path = string(@__DIR__)\njulia>  output_fldr = \"OUTPUT\"\njulia>  output_dir = joinpath(cur_path, output_fldr)\njulia>  if !ispath(output_dir)\n         mkpath(output_dir)\n        end \n\n###\n#------------------------------------------------------------------------\n#Set exogenous parameters\n#------------------------------------------------------------------------\n#yrs_in_per = integer >= 1, number of years in a model period\n#beta_an    = scalar in (0, 1), annual discount factor\n#beta       = scalar in (0, 1), model period discount factor\n#gamma      = scalar >= 1, coefficient of relative risk aversion\n#c_min      = scalar > 0, minimum individual consumption\n#K_min      = scalar > 0, minimum aggregate capital stock\n#n_1        = scalar >= 0, exogenous labor supply when young\n#n_2        = scalar >= 0, exogenous labor supply when old\n#n_vec      = (2,) vector, lifetime exogenous labor supply\n#alpha      = scalar in (0, 1), capital share of income\n#delta_an   = scalar in (0, 1], annual depreciation rate\n#delta      = scalar in (0, 1], model period depreciation rate\n#rho_an     = scalar in (-1, 1), annual persistence of normally\n#             distributed TFP process\n#rho        = scalar in (-1, 1), model period persistence of normally\n#             distributed TFP process\n#mu         = scalar, unconditional mean of normally distributed TFP\n#             process\n#sigma_an   = scalar > 0, annual standard deviation of normally\n#             distributed TFP process\n#rho_sum    = scalar, recursive geometric sum of rho ** 2\n#y_ind      = integer >= 0, index of yrs_in_per\n#sigma      = scalar > 0, model period standard deviation of normally\n#             distributed TFP process\n#A_min      = scalar >= 0, minimum value in support of lognormally\n#             distributed TFP process\n#z_min      = scalar, minimum value in support of normally distributed\n#             TFP process\n#Hbar_vec   = (Hbar_size,) vector, values of Hbar\n#Hbar_size  = integer >= 1, number of values of Hbar\n#k20_vec    = (Hbar_size,) vector, values of k20\n#k20_size   = integer >= 1, number of values of k20_vec\n#z0         = scalar, initial normally distributed TFP value\n#T          = integer > 1, maximum number of periods to simulate\n#S          = integer >= 1, number of simulations\n#rand_seed  = integer > 0, random seed for simulation\n#------------------------------------------------------------------------\n#'''\n\njulia>  yrs_in_per = 25\njulia>  beta_an = 0.96\njulia>  beta = beta_an^yrs_in_per\njulia>  gamma = 2.2\njulia>  c_min = 1e-5\njulia>  K_min = 1e-5\n\n# Firm parameters\njulia>  alpha = 1/3\njulia>  epsilon = 1.0\njulia>  delta_an = 0.0\njulia>  delta = 1 - ((1 - delta_an)^yrs_in_per)\njulia>  nvec = Array([1.0, 0.0])\n\n# Aggregate shock z parameters\njulia>  rho_an = 0.95\njulia>  rho = rho_an^yrs_in_per\njulia>  mu_an = 0.0\njulia>  sigma_an = 0.2  # 0.4946\njulia>  rho_sum = 0.0\njulia>  rho2_sum = 0.0\njulia>  for y_ind in range(0,stop = (yrs_in_per-1),step = 1)\n            rho_sum = rho_sum + rho_an^y_ind\n            rho2_sum = rho2_sum + rho_an^(2*y_ind)\n        end \njulia>  sigma = sqrt(rho2_sum*(sigma_an^2))\njulia>  mu = mu_an*rho_sum\njulia>  A_min = 0.0\njulia>  if A_min == 0.0\n             z_min = -Inf\n        elseif (A_min > 0.0) && (A_min < exp(mu))\n              z_min = log(A_min)\n        elseif A_min >= exp(mu)\n        print(\"Parameter Error: A_min >= e^(mu)\")\n        end\n        \n\n# Set government parameters, transfer parameters, and initial values\njulia>  Hbar_vec = Array([0.0, 0.05])\n# self.Hbar_vec = Array([0.0, 0.05, 0.11, 0.17])\njulia>  Hbar_size = length(Hbar_vec)\njulia>  Hbar = Hbar_vec[1]\njulia>  tau = nothing\njulia>  z0 = mu\n\n# Set simulation parameters\njulia>  T = 25\njulia>  S = 15\njulia>  rand_seed = 25\n\n# print(\"sigma\")\n# print(sigma)\n# print(\" \")\n# print(\"beta\")\n# print(beta)\n# print(\" \")\n\n\n\"\"\"\n------------------------------------------------------------------------\nCalibrate beta, mu, gamma\n------------------------------------------------------------------------\n\"\"\"\n\njulia>  avg_rtp1_size = 3\njulia>  avg_rtp1_an_vec = Array(range(0.00,stop = 0.04,length = avg_rtp1_size))\njulia>  avg_Rtp1_vec = (1 .+ avg_rtp1_an_vec).^yrs_in_per\njulia>  avg_rbart_size = 3\njulia>  avg_rbart_an_vec = Array(range(-0.02,stop = 0.01, length = avg_rbart_size))\njulia>  avg_Rbart_vec = (1 .+ avg_rbart_an_vec).^yrs_in_per\n\n# print(\"avg_Rtp1_vec\")\n# print(avg_Rtp1_vec)\n# print(\" \")\n# print(\"avg_Rbart_vec\")\n# print(avg_Rbart_vec)\n# print(\" \")\n\njulia>  avgRtp1_mat = repeat(reshape(avg_Rtp1_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  avgRbart_mat = repeat(reshape(avg_Rbart_vec,(1, avg_rbart_size)), avg_rtp1_size, 1)\njulia>  avgRtp1_gt_avgRbart = ((avgRtp1_mat - avgRbart_mat) .> 0) \n# print(avgRtp1_gt_avgRbart)\n\n# Calibrate mu using linear production expected MPK\njulia>  mu_vec = 1.0786 .* fill!(similar(avg_Rtp1_vec), 1)\njulia>  mu_vec = log.(avg_Rtp1_vec) .- log(alpha) .- ((sigma^2) / 2)\njulia>  mu_mat[.!avgRtp1_gt_avgRbart] .= NaN \n\n# Calibrate beta using Cobb-Douglas expected values expression for beta\njulia>  beta_vec = (alpha / (1 - alpha)) .* (1 ./ (2 * avg_Rtp1_vec)) \njulia>  beta_an_vec = beta_vec.^(1 / yrs_in_per)\njulia>  beta_mat = repeat(reshape(beta_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  beta_mat[.!avgRtp1_gt_avgRbart] .=  NaN\n\n# Calibrate gamma\njulia>  gamma_mat = ((log.(avgRtp1_mat) - log.(avgRbart_mat)) ./ (sigma^2))\njulia>  gamma_mat[.!avgRtp1_gt_avgRbart]  .=  NaN\n\n# Calibrate x_1\njulia>  x1_mat = (((1 - alpha) * exp.(mu_mat .+ ((sigma ^ 2) / 2)) .* ((2 * beta_mat) .^alpha)) .^ (1 / (1 - alpha)))\n\n# Calibrate kbar_2\njulia>  kbar2_mat = 2 .* beta_mat .* x1_mat\njulia>  Hbar_vec[2] = 0.05 * kbar2_mat[1, 1] # 1.0786\n# print(\"Hbar_vec = \", Hbar_vec)\n\n# Calibrate x_1 array for different values of x1, given calibration\njulia>  x1_mat2 = transpose(x1_mat)\njulia>  x1_arr = zeros(3, avg_rtp1_size, avg_rbart_size) \njulia>  x1_arr[:, 1, :] = x1_mat2 \njulia>  x1_arr[:, 2, :] = 0.5 .* x1_mat2\njulia>  x1_arr[:, 3, :] = 0.0 .* x1_mat2 \n\n# Calibrate sigma vector of 5% and 10% increases\njulia>  sigma_vec = zeros(3)\njulia>  sigma_vec[1] = sigma\njulia>  sigma_vec[2] = 1.05 * sigma\njulia>  sigma_vec[3] = 1.10 * sigma\n\n# Calibrate corresponding mu_arr that holds the expected value of the\n# TFP shock while expanding the variance. If ExpA is the expected value of\n# the TFP shock, then ExpA = exp.(mu .+ (sig^2) / 2), then\n# log.(ExpA) = mu .+ (sig^2) / 2\njulia>  ExpA = mu_mat .+ (sigma ^ 2) / 2\njulia>  mu_mat2 = transpose(mu_mat)\njulia>  mu_arr = zeros(3, avg_rtp1_size, avg_rbart_size)\njulia>  mu_arr[:, 1, :] = mu_mat2\njulia>  mu_arr[:, 2, :] = mu_mat2\njulia>  mu_arr[:, 3, :] = mu_mat2\n# mu_arr[:, :, 2] = ExpA .- (sigma_vec[2] ^ 2) / 2\n# mu_arr[:, :, 3] = ExpA .- (sigma_vec[3] ^ 2) / 2\n\n# print(\"mu_mat\")\n# print(mu_mat)\n# print(\" \")\n# print(\"beta_mat\")\n# print(beta_mat)\n# print(\" \")\n# print(\"gamma_mat\")\n# print(gamma_mat)\n# print(\" \")\n# print(\"x1_mat\")\n# print(x1_mat)\n# print(\" \")\n# print(\"kbar2_mat\")\n# print(kbar2_mat)\n# print(\" \")\n# print(\"x1_arr 1\")\n# print(x1_arr[:, :, 1])\n# print(\" \")\n# print(\"x1_arr 2\")\n# print(x1_arr[:, :, 2])\n# print(\" \")\n# print(\"x1_arr 3\")\n# print(x1_arr[:, :, 3])\n# print(\" \")\n# print(\"sigma_vec\")\n# print(sigma_vec)\n# print(\" \")\n# print(\"mu_arr 1\")\n# print(mu_arr[:, :, 1])\n# print(\" \")\n# print(\"mu_arr 2\")\n# print(mu_arr[:, :, 2])\n# print(\" \")\n# print(\"mu_arr 3\")\n# print(mu_arr[:, :, 3])\n# print(\" \")\n\njulia>  default_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  Random.seed!(rand_seed) \njulia>  unif_mat = rand(Uniform(0, 1), (S, T))\n\n# First three dimensions of zt_arr correspond to mu_arr in different order\njulia>  zt_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3)\n\njulia>  cut_lb = 0\njulia>  eps_t = 0\njulia>  z_t = 0\njulia>  z_tm1 = 0\n\njulia>  for sig_ind in range(1, stop=(3), step=1)\n            sigma = sigma_vec[sig_ind]\n             for avgrtp1_ind in range(1, stop=(avg_rtp1_size), step=1)\n                for avgrbart_ind in range(1, stop=(avg_rbart_size), step=1)\n                  mu = mu_arr[avgrbart_ind, sig_ind, avgrtp1_ind]\n                    for s_ind in range(1, stop=(S), step=1)\n                         for t_ind in range(1, stop=(T), step=1)\n                            unif = unif_mat[s_ind, t_ind]\n                                 if t_ind == 1 && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true\n                                    cut_lb = z_min - mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                    z_t = mu + eps_t\n                                 elseif ((t_ind > 1) && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true)\n                                    z_tm1 = zt_arr[s_ind, t_ind - 1, avgrbart_ind, avgrtp1_ind, sig_ind]\n                                    cut_lb = z_min - rho * z_tm1 - (1 - rho) * mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                     z_t = rho * z_tm1 + (1 - rho) * mu .+ eps_t \n                                  else\n                                      z_t = NaN\n                                  end\n                             zt_arr[s_ind, t_ind, avgrbart_ind,  avgrtp1_ind, sig_ind] = z_t  \n                           end \n                        end \n                     end \n                 end \n            end \n\njulia>  c1t_arr = zero(default_arr)\njulia>  c2t_arr = zero(default_arr)\njulia>  ut_arr = zeros(S, T - 1, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  Ht_arr = zero(default_arr)\njulia>  wt_arr = zero(default_arr)\njulia>  rt_arr = zero(default_arr)\njulia>  k2t_arr = zero(default_arr)\njulia>  rbart_arr = zero(default_arr)\njulia>  rbart_an_arr = zero(default_arr)\njulia>  EulErr_arr = zero(default_arr)\njulia>  PathTime_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  s_ind_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  for rtp1_ind in range(1, stop=(avg_rtp1_size), step=1) \n            for rbart_ind in range(1, stop=(avg_rbart_size), step=1) \n                 kbar2_mat2 = (!iszero).(kbar2_mat)\n                 k2t_arr[:, 1, rbart_ind, rtp1_ind, :, :, :] .=  kbar2_mat2[rtp1_ind, rbart_ind]\n            end\n        end\n\njulia>  mu_in = 0\njulia>  sigma_in = 0\njulia>  x1_in = 0\njulia>  z0_vec_in = 0\njulia>  gamma_in = 0\njulia>  beta_in = 0\njulia>  k20_in = 0\njulia>  simulations = 0\njulia>  H_ind = 1\njulia>  risk_type_ind = 1\njulia>  risk_val_ind = 1\njulia>  avgrtp1_ind = 1\njulia>  avgrbart_ind = 1\njulia>  timepaths_s = 0\njulia>  for H_ind in 1:Hbar_size\n            Hbar_in = Hbar_vec[H_ind]\n              for risk_type_ind in 1:2 #0=xval, 1=sigval\n                 for risk_val_ind in 1:3\n                        for avgrtp1_ind in 1:avg_rtp1_size\n                          for avgrbart_ind in 1:avg_rbart_size\n                             if avgRtp1_gt_avgRbart[avgrtp1_ind, avgrbart_ind]\n                                   simulations = []\n                                   beta_in = beta_mat[avgrtp1_ind, avgrbart_ind]\n                                   gamma_in = gamma_mat[avgrtp1_ind, avgrbart_ind]\n                                   k20_in = kbar2_mat[avgrtp1_ind, avgrbart_ind]\n                                  if risk_type_ind == 1\n                                        mu_in = mu_mat[avgrtp1_ind, avgrbart_ind]\n                                        sigma_in = sigma_vec[1]\n                                        x1_in = x1_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                        z0_vec_in = zt_arr[:, 1, avgrbart_ind, avgrtp1_ind, 1]\n                                   elseif risk_type_ind == 2 \n                                         mu_in = mu_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                         sigma_in = sigma_vec[risk_val_ind]\n                                         x1_in = x1_mat[avgrtp1_ind, avgrbart_ind]\n                                         z0_vec_in = zt_arr[ :, 1, avgrbart_ind, avgrtp1_ind, risk_val_ind,]\n                                    end\n\n                                    for s_ind in 1:S\n                                       z0_in = z0_vec_in[s_ind]\n                                        if risk_type_ind == 1\n                                                zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, 1]\n                                        elseif risk_type_ind == 2\n                                            zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_type_ind,]\n                                        end\n                                     timepaths_s = sim_timepath(\n                                         Hbar_in, beta_in, gamma_in, k20_in,\n                                         sigma_in, x1_in, T, z0_in, z_min, rho,\n                                          mu_in, nvec, epsilon, alpha, delta, tau,\n                                          c_min, K_min, A_min, yrs_in_per,\n                                          H_ind,\n                                          risk_type_ind,\n                                          risk_val_ind,\n                                          avgrtp1_ind,\n                                          avgrbart_ind, s_ind,\n                                          zt_vec_in,\n                                          rand_seed)\n                                     push!(simulations, timepaths_s)\n                                  end\n                        \n                        for s_ind in 1:S\n                            s_ind_arr[avgrbart_ind, s_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][6] # original S_ind\n                            default_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][8]  # default_vec\n                            c1t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][9])  # c1t_vec\n                            c2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][10])  # c2t_vec\n                            ut_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][11]  # ut_vec\n                            Ht_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][12])  # Ht_vec\n                            wt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][13])  # wt_vec\n                            rt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][14])  # rt_vec\n                            pop!(simulations[s_ind][15])\n                            k2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][15])  #        k2t_vec[:-1]\n                            rbart_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][16])  # rbart_vec\n                            rbart_an_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][17])  # rbart_an_vec\n                            EulErr_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][18])  # EulErr_vec\n                        end\n\n                    else  # avg_Rtp1 <= avg_rbart\n                        s_ind_arr[avgrbart_ind, :, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN \n                        default_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # default_vec\n                        c1t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c1t_vec\n                        c2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c2t_vec\n                        ut_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # ut_vec\n                        Ht_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # Ht_vec\n                        wt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # wt_vec\n                        rt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rt_vec\n                        k2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # k2t_vec[:-1]\n                        rbart_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rbart_vec\n                        rbart_an_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # rbart_an_vec\n                        EulErr_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # EulErr_vec\n                    end\n                end\n\n            dict_endog_new = Dict(\n                \"unif_mat\" => unif_mat,\n                \"zt_arr\" => zt_arr ,\n                \"c1t_arr\" => c1t_arr,\n                \"c2t_arr\"=> c2t_arr,\n                \"ut_arr\" => ut_arr,\n                \"Ht_arr\" => Ht_arr,\n                \"wt_arr\" => wt_arr,\n                \"rt_arr\" => rt_arr,\n                \"rbart_arr\" => rbart_arr,\n                \"rbart_an_arr\" => rbart_an_arr,\n                \"k2t_arr\" => k2t_arr,\n                \"EulErr_arr\" => EulErr_arr,\n                \"default_arr\" => default_arr,\n                \"s_ind_arr\" => s_ind_arr)\n                  \n            save(\"dict_endog_$(H_ind)$(risk_type_ind)$(risk_val_ind).jld2\", dict_endog_new)\n\n            end\n        end\n    end\nend\n\n\njulia> default_p1 = default_arr\njulia> default_p1[:, 1, :, :, :, :, :] = zeros(S, 1, 3, 3, 3, 2, 2)\n\njulia> zt_arr_macro = repeat(reshape(zt_arr,(S, T, avg_rbart_size, avg_rtp1_size, 3, 1, 1)), 1, 1, 1, 1, 1, Hbar_size, 2)\n\njulia> Kt_arr = (1 .- default_p1) .* k2t_arr\njulia> Y_args = (nvec, epsilon, alpha)\njulia> Yt_arr = (1 .- default_p1) .* get_Y(Kt_arr, zt_arr_macro, Y_args)\njulia> Ct_arr = (1 .- default_p1) .* get_C(c1t_arr, c2t_arr)\n\njulia> dict_params = Dict(\n        \"yrs_in_per\" => yrs_in_per,\n        \"beta_an\" => beta_an,\n        \"beta\" => beta,\n        \"gamma\" => gamma,\n        \"c_min\" => c_min,\n        \"K_min\" => K_min,\n        \"nvec\" => nvec,\n        \"n1\" => nvec[1],\n        \"n2\" => nvec[2],\n        \"alpha\" => alpha,\n        \"epsilon\" => epsilon,\n        \"delta_an\" => delta_an,\n        \"delta\" => delta,\n        \"rho_an\" => rho_an,\n        \"rho\" => rho,\n        \"mu_an\" => mu_an,\n        \"sigma_an\" => sigma_an,\n        \"sigma\" => sigma,\n        \"mu\" => mu,\n        \"A_min\" => A_min,\n        \"z_min\" => z_min,\n        \"Hbar_vec\" => Hbar_vec,\n        \"Hbar_size\" => Hbar_size,\n        \"Hbar\" => Hbar,\n        \"tau\" => tau,\n        \"T\" => T,\n        \"S\" => S,\n        \"rand_seed\" => rand_seed,\n        \"max_cores\" => max_cores,\n        \"num_workers\" => num_workers,\n        \"avg_rtp1_size\" => avg_rtp1_size,\n        \"avg_rtp1_an_vec\" => avg_rtp1_an_vec,\n        \"avg_Rtp1_vec\" => avg_Rtp1_vec,\n        \"avg_rbart_size\" => avg_rbart_size,\n        \"avg_rbart_an_vec\" => avg_rbart_an_vec,\n        \"avg_Rbart_vec\" => avg_Rbart_vec,\n        \"avgRtp1_mat\" => avgRtp1_mat,\n        \"avgRbart_mat\" => avgRbart_mat,\n        \"avgRtp1_gt_avgRbart\" => avgRtp1_gt_avgRbart,\n        \"mu_vec\" => mu_vec,\n        \"mu_mat\" => mu_mat,\n        \"mu_arr\" => mu_arr,\n        \"beta_vec\" => beta_vec,\n        \"beta_mat\" => beta_mat,\n        \"gamma_mat\" => gamma_mat,\n        \"x1_mat\" => x1_mat,\n        \"x1_arr\" => x1_arr,\n        \"kbar2_mat\" => kbar2_mat,\n        \"sigma_vec\" => sigma_vec,\n        \"ExpA\" => ExpA)\n\njulia> dict_endog = Dict(\n        \"unif_mat\" => unif_mat,\n        \"zt_arr\" => zt_arr ,\n        \"c1t_arr\" =>  c1t_arr,\n        \"c2t_arr\"=>  c2t_arr,\n        \"ut_arr\" =>  ut_arr,\n        \"Ht_arr\" =>  Ht_arr,\n        \"wt_arr\" =>  wt_arr,\n        \"rt_arr\" =>  rt_arr,\n        \"rbart_arr\" =>  rbart_arr,\n        \"rbart_an_arr\" => rbart_an_arr,\n        \"k2t_arr\" =>  k2t_arr,\n        \"EulErr_arr\" =>  EulErr_arr,\n        \"Kt_arr\" => Kt_arr,\n        \"Yt_arr\"=> Yt_arr,\n        \"Ct_arr\" => Ct_arr,\n        \"default_arr\" =>  default_arr,\n        \"s_ind_arr\" =>  s_ind_arr)\n\nresults_sims = Dict(\"dict_params\" => dict_params, \"dict_endog\" => dict_endog)\nsave(\"results_sims.jld2\", results_sims)","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"(Image: Table2)","category":"page"},{"location":"#Case-number-4-:-\\varepsilon-\\infty-and-\\mu-is-a-function-of-E[R_{t1}]","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Case number 4 : varepsilon = infty and mu is a function of ER_t+1","text":"","category":"section"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"We run simulations, as before, for 15 time series and 25 period for each. Here, the production function is lenear and the risk mu is a function of the expected interest rate. ","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"julia> using Evans2020\n\njulia> include(\"FUNC_NPC.jl\")\n\n# Create OUTPUT directory if does not already exist\njulia>  cur_path = string(@__DIR__)\njulia>  output_fldr = \"OUTPUT\"\njulia>  output_dir = joinpath(cur_path, output_fldr)\njulia>  if !ispath(output_dir)\n         mkpath(output_dir)\n        end \n\n###\n#------------------------------------------------------------------------\n#Set exogenous parameters\n#------------------------------------------------------------------------\n#yrs_in_per = integer >= 1, number of years in a model period\n#beta_an    = scalar in (0, 1), annual discount factor\n#beta       = scalar in (0, 1), model period discount factor\n#gamma      = scalar >= 1, coefficient of relative risk aversion\n#c_min      = scalar > 0, minimum individual consumption\n#K_min      = scalar > 0, minimum aggregate capital stock\n#n_1        = scalar >= 0, exogenous labor supply when young\n#n_2        = scalar >= 0, exogenous labor supply when old\n#n_vec      = (2,) vector, lifetime exogenous labor supply\n#alpha      = scalar in (0, 1), capital share of income\n#delta_an   = scalar in (0, 1], annual depreciation rate\n#delta      = scalar in (0, 1], model period depreciation rate\n#rho_an     = scalar in (-1, 1), annual persistence of normally\n#             distributed TFP process\n#rho        = scalar in (-1, 1), model period persistence of normally\n#             distributed TFP process\n#mu         = scalar, unconditional mean of normally distributed TFP\n#             process\n#sigma_an   = scalar > 0, annual standard deviation of normally\n#             distributed TFP process\n#rho_sum    = scalar, recursive geometric sum of rho ** 2\n#y_ind      = integer >= 0, index of yrs_in_per\n#sigma      = scalar > 0, model period standard deviation of normally\n#             distributed TFP process\n#A_min      = scalar >= 0, minimum value in support of lognormally\n#             distributed TFP process\n#z_min      = scalar, minimum value in support of normally distributed\n#             TFP process\n#Hbar_vec   = (Hbar_size,) vector, values of Hbar\n#Hbar_size  = integer >= 1, number of values of Hbar\n#k20_vec    = (Hbar_size,) vector, values of k20\n#k20_size   = integer >= 1, number of values of k20_vec\n#z0         = scalar, initial normally distributed TFP value\n#T          = integer > 1, maximum number of periods to simulate\n#S          = integer >= 1, number of simulations\n#rand_seed  = integer > 0, random seed for simulation\n#------------------------------------------------------------------------\n#'''\n\njulia>  yrs_in_per = 25\njulia>  beta_an = 0.96\njulia>  beta = beta_an^yrs_in_per\njulia>  gamma = 2.2\njulia>  c_min = 1e-5\njulia>  K_min = 1e-5\n\n# Firm parameters\njulia>  alpha = 1/3\njulia>  epsilon = Inf\njulia>  delta_an = 0.0\njulia>  delta = 1 - ((1 - delta_an)^yrs_in_per)\njulia>  nvec = Array([1.0, 0.0])\n\n# Aggregate shock z parameters\njulia>  rho_an = 0.95\njulia>  rho = rho_an^yrs_in_per\njulia>  mu_an = 0.0\njulia>  sigma_an = 0.2  # 0.4946\njulia>  rho_sum = 0.0\njulia>  rho2_sum = 0.0\njulia>  for y_ind in range(0,stop = (yrs_in_per-1),step = 1)\n            rho_sum = rho_sum + rho_an^y_ind\n            rho2_sum = rho2_sum + rho_an^(2*y_ind)\n        end \njulia>  sigma = sqrt(rho2_sum*(sigma_an^2))\njulia>  mu = mu_an*rho_sum\njulia>  A_min = 0.0\njulia>  if A_min == 0.0\n             z_min = -Inf\n        elseif (A_min > 0.0) && (A_min < exp(mu))\n              z_min = log(A_min)\n        elseif A_min >= exp(mu)\n        print(\"Parameter Error: A_min >= e^(mu)\")\n        end\n        \n\n# Set government parameters, transfer parameters, and initial values\njulia>  Hbar_vec = Array([0.0, 0.05])\n# self.Hbar_vec = Array([0.0, 0.05, 0.11, 0.17])\njulia>  Hbar_size = length(Hbar_vec)\njulia>  Hbar = Hbar_vec[1]\njulia>  tau = nothing\njulia>  z0 = mu\n\n# Set simulation parameters\njulia>  T = 25\njulia>  S = 15\njulia>  rand_seed = 25\n\n# print(\"sigma\")\n# print(sigma)\n# print(\" \")\n# print(\"beta\")\n# print(beta)\n# print(\" \")\n\n\n\"\"\"\n------------------------------------------------------------------------\nCalibrate beta, mu, gamma\n------------------------------------------------------------------------\n\"\"\"\n\njulia>  avg_rtp1_size = 3\njulia>  avg_rtp1_an_vec = Array(range(0.00,stop = 0.04,length = avg_rtp1_size))\njulia>  avg_Rtp1_vec = (1 .+ avg_rtp1_an_vec).^yrs_in_per\njulia>  avg_rbart_size = 3\njulia>  avg_rbart_an_vec = Array(range(-0.02,stop = 0.01, length = avg_rbart_size))\njulia>  avg_Rbart_vec = (1 .+ avg_rbart_an_vec).^yrs_in_per\n\n# print(\"avg_Rtp1_vec\")\n# print(avg_Rtp1_vec)\n# print(\" \")\n# print(\"avg_Rbart_vec\")\n# print(avg_Rbart_vec)\n# print(\" \")\n\njulia>  avgRtp1_mat = repeat(reshape(avg_Rtp1_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  avgRbart_mat = repeat(reshape(avg_Rbart_vec,(1, avg_rbart_size)), avg_rtp1_size, 1)\njulia>  avgRtp1_gt_avgRbart = ((avgRtp1_mat - avgRbart_mat) .> 0) \n# print(avgRtp1_gt_avgRbart)\n\n# Calibrate mu using linear production expected MPK\njulia>  mu_vec = 1.0786 .* fill!(similar(avg_Rtp1_vec), 1)\njulia>  mu_vec = log.(avg_Rtp1_vec) .- log(alpha) .- ((sigma^2) / 2)\njulia>  mu_mat[.!avgRtp1_gt_avgRbart] .= NaN \n\n# Calibrate beta using Cobb-Douglas expected values expression for beta\njulia>  beta_vec = (alpha / (1 - alpha)) .* (1 ./ (2 * avg_Rtp1_vec)) \njulia>  beta_an_vec = beta_vec.^(1 / yrs_in_per)\njulia>  beta_mat = repeat(reshape(beta_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)\njulia>  beta_mat[.!avgRtp1_gt_avgRbart] .=  NaN\n\n# Calibrate gamma\njulia>  gamma_mat = ((log.(avgRtp1_mat) - log.(avgRbart_mat)) ./ (sigma^2))\njulia>  gamma_mat[.!avgRtp1_gt_avgRbart]  .=  NaN\n\n# Calibrate x_1\njulia>  x1_mat = (((1 - alpha) * exp.(mu_mat .+ ((sigma ^ 2) / 2)) .* ((2 * beta_mat) .^alpha)) .^ (1 / (1 - alpha)))\n\n# Calibrate kbar_2\njulia>  kbar2_mat = 2 .* beta_mat .* x1_mat\njulia>  Hbar_vec[2] = 0.05 * kbar2_mat[1, 1] # 1.0786\n# print(\"Hbar_vec = \", Hbar_vec)\n\n# Calibrate x_1 array for different values of x1, given calibration\njulia>  x1_mat2 = transpose(x1_mat)\njulia>  x1_arr = zeros(3, avg_rtp1_size, avg_rbart_size) \njulia>  x1_arr[:, 1, :] = x1_mat2 \njulia>  x1_arr[:, 2, :] = 0.5 .* x1_mat2\njulia>  x1_arr[:, 3, :] = 0.0 .* x1_mat2 \n\n# Calibrate sigma vector of 5% and 10% increases\njulia>  sigma_vec = zeros(3)\njulia>  sigma_vec[1] = sigma\njulia>  sigma_vec[2] = 1.05 * sigma\njulia>  sigma_vec[3] = 1.10 * sigma\n\n# Calibrate corresponding mu_arr that holds the expected value of the\n# TFP shock while expanding the variance. If ExpA is the expected value of\n# the TFP shock, then ExpA = exp.(mu .+ (sig^2) / 2), then\n# log.(ExpA) = mu .+ (sig^2) / 2\njulia>  ExpA = mu_mat .+ (sigma ^ 2) / 2\njulia>  mu_mat2 = transpose(mu_mat)\njulia>  mu_arr = zeros(3, avg_rtp1_size, avg_rbart_size)\njulia>  mu_arr[:, 1, :] = mu_mat2\njulia>  mu_arr[:, 2, :] = mu_mat2\njulia>  mu_arr[:, 3, :] = mu_mat2\n# mu_arr[:, :, 2] = ExpA .- (sigma_vec[2] ^ 2) / 2\n# mu_arr[:, :, 3] = ExpA .- (sigma_vec[3] ^ 2) / 2\n\n# print(\"mu_mat\")\n# print(mu_mat)\n# print(\" \")\n# print(\"beta_mat\")\n# print(beta_mat)\n# print(\" \")\n# print(\"gamma_mat\")\n# print(gamma_mat)\n# print(\" \")\n# print(\"x1_mat\")\n# print(x1_mat)\n# print(\" \")\n# print(\"kbar2_mat\")\n# print(kbar2_mat)\n# print(\" \")\n# print(\"x1_arr 1\")\n# print(x1_arr[:, :, 1])\n# print(\" \")\n# print(\"x1_arr 2\")\n# print(x1_arr[:, :, 2])\n# print(\" \")\n# print(\"x1_arr 3\")\n# print(x1_arr[:, :, 3])\n# print(\" \")\n# print(\"sigma_vec\")\n# print(sigma_vec)\n# print(\" \")\n# print(\"mu_arr 1\")\n# print(mu_arr[:, :, 1])\n# print(\" \")\n# print(\"mu_arr 2\")\n# print(mu_arr[:, :, 2])\n# print(\" \")\n# print(\"mu_arr 3\")\n# print(mu_arr[:, :, 3])\n# print(\" \")\n\njulia>  default_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  Random.seed!(rand_seed) \njulia>  unif_mat = rand(Uniform(0, 1), (S, T))\n\n# First three dimensions of zt_arr correspond to mu_arr in different order\njulia>  zt_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3)\n\njulia>  cut_lb = 0\njulia>  eps_t = 0\njulia>  z_t = 0\njulia>  z_tm1 = 0\n\njulia>  for sig_ind in range(1, stop=(3), step=1)\n            sigma = sigma_vec[sig_ind]\n             for avgrtp1_ind in range(1, stop=(avg_rtp1_size), step=1)\n                for avgrbart_ind in range(1, stop=(avg_rbart_size), step=1)\n                  mu = mu_arr[avgrbart_ind, sig_ind, avgrtp1_ind]\n                    for s_ind in range(1, stop=(S), step=1)\n                         for t_ind in range(1, stop=(T), step=1)\n                            unif = unif_mat[s_ind, t_ind]\n                                 if t_ind == 1 && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true\n                                    cut_lb = z_min - mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                    z_t = mu + eps_t\n                                 elseif ((t_ind > 1) && avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true)\n                                    z_tm1 = zt_arr[s_ind, t_ind - 1, avgrbart_ind, avgrtp1_ind, sig_ind]\n                                    cut_lb = z_min - rho * z_tm1 - (1 - rho) * mu\n                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)\n                                     z_t = rho * z_tm1 + (1 - rho) * mu .+ eps_t \n                                  else\n                                      z_t = NaN\n                                  end\n                             zt_arr[s_ind, t_ind, avgrbart_ind,  avgrtp1_ind, sig_ind] = z_t  \n                           end \n                        end \n                     end \n                 end \n            end \n\njulia>  c1t_arr = zero(default_arr)\njulia>  c2t_arr = zero(default_arr)\njulia>  ut_arr = zeros(S, T - 1, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  Ht_arr = zero(default_arr)\njulia>  wt_arr = zero(default_arr)\njulia>  rt_arr = zero(default_arr)\njulia>  k2t_arr = zero(default_arr)\njulia>  rbart_arr = zero(default_arr)\njulia>  rbart_an_arr = zero(default_arr)\njulia>  EulErr_arr = zero(default_arr)\njulia>  PathTime_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\njulia>  s_ind_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)\n\njulia>  for rtp1_ind in range(1, stop=(avg_rtp1_size), step=1) \n            for rbart_ind in range(1, stop=(avg_rbart_size), step=1) \n                 kbar2_mat2 = (!iszero).(kbar2_mat)\n                 k2t_arr[:, 1, rbart_ind, rtp1_ind, :, :, :] .=  kbar2_mat2[rtp1_ind, rbart_ind]\n            end\n        end\n\njulia>  mu_in = 0\njulia>  sigma_in = 0\njulia>  x1_in = 0\njulia>  z0_vec_in = 0\njulia>  gamma_in = 0\njulia>  beta_in = 0\njulia>  k20_in = 0\njulia>  simulations = 0\njulia>  H_ind = 1\njulia>  risk_type_ind = 1\njulia>  risk_val_ind = 1\njulia>  avgrtp1_ind = 1\njulia>  avgrbart_ind = 1\njulia>  timepaths_s = 0\njulia>  for H_ind in 1:Hbar_size\n            Hbar_in = Hbar_vec[H_ind]\n              for risk_type_ind in 1:2 #0=xval, 1=sigval\n                 for risk_val_ind in 1:3\n                        for avgrtp1_ind in 1:avg_rtp1_size\n                          for avgrbart_ind in 1:avg_rbart_size\n                             if avgRtp1_gt_avgRbart[avgrtp1_ind, avgrbart_ind]\n                                   simulations = []\n                                   beta_in = beta_mat[avgrtp1_ind, avgrbart_ind]\n                                   gamma_in = gamma_mat[avgrtp1_ind, avgrbart_ind]\n                                   k20_in = kbar2_mat[avgrtp1_ind, avgrbart_ind]\n                                  if risk_type_ind == 1\n                                        mu_in = mu_mat[avgrtp1_ind, avgrbart_ind]\n                                        sigma_in = sigma_vec[1]\n                                        x1_in = x1_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                        z0_vec_in = zt_arr[:, 1, avgrbart_ind, avgrtp1_ind, 1]\n                                   elseif risk_type_ind == 2 \n                                         mu_in = mu_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]\n                                         sigma_in = sigma_vec[risk_val_ind]\n                                         x1_in = x1_mat[avgrtp1_ind, avgrbart_ind]\n                                         z0_vec_in = zt_arr[ :, 1, avgrbart_ind, avgrtp1_ind, risk_val_ind,]\n                                    end\n\n                                    for s_ind in 1:S\n                                       z0_in = z0_vec_in[s_ind]\n                                        if risk_type_ind == 1\n                                                zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, 1]\n                                        elseif risk_type_ind == 2\n                                            zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_type_ind,]\n                                        end\n                                     timepaths_s = sim_timepath(\n                                         Hbar_in, beta_in, gamma_in, k20_in,\n                                         sigma_in, x1_in, T, z0_in, z_min, rho,\n                                          mu_in, nvec, epsilon, alpha, delta, tau,\n                                          c_min, K_min, A_min, yrs_in_per,\n                                          H_ind,\n                                          risk_type_ind,\n                                          risk_val_ind,\n                                          avgrtp1_ind,\n                                          avgrbart_ind, s_ind,\n                                          zt_vec_in,\n                                          rand_seed)\n                                     push!(simulations, timepaths_s)\n                                  end\n                        \n                        for s_ind in 1:S\n                            s_ind_arr[avgrbart_ind, s_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][6] # original S_ind\n                            default_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][8]  # default_vec\n                            c1t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][9])  # c1t_vec\n                            c2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][10])  # c2t_vec\n                            ut_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][11]  # ut_vec\n                            Ht_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][12])  # Ht_vec\n                            wt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][13])  # wt_vec\n                            rt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][14])  # rt_vec\n                            pop!(simulations[s_ind][15])\n                            k2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][15])  #        k2t_vec[:-1]\n                            rbart_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][16])  # rbart_vec\n                            rbart_an_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][17])  # rbart_an_vec\n                            EulErr_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][18])  # EulErr_vec\n                        end\n\n                    else  # avg_Rtp1 <= avg_rbart\n                        s_ind_arr[avgrbart_ind, :, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN \n                        default_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # default_vec\n                        c1t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c1t_vec\n                        c2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c2t_vec\n                        ut_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # ut_vec\n                        Ht_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # Ht_vec\n                        wt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # wt_vec\n                        rt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rt_vec\n                        k2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # k2t_vec[:-1]\n                        rbart_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rbart_vec\n                        rbart_an_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # rbart_an_vec\n                        EulErr_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # EulErr_vec\n                    end\n                end\n\n            dict_endog_new = Dict(\n                \"unif_mat\" => unif_mat,\n                \"zt_arr\" => zt_arr ,\n                \"c1t_arr\" => c1t_arr,\n                \"c2t_arr\"=> c2t_arr,\n                \"ut_arr\" => ut_arr,\n                \"Ht_arr\" => Ht_arr,\n                \"wt_arr\" => wt_arr,\n                \"rt_arr\" => rt_arr,\n                \"rbart_arr\" => rbart_arr,\n                \"rbart_an_arr\" => rbart_an_arr,\n                \"k2t_arr\" => k2t_arr,\n                \"EulErr_arr\" => EulErr_arr,\n                \"default_arr\" => default_arr,\n                \"s_ind_arr\" => s_ind_arr)\n                  \n            save(\"dict_endog_$(H_ind)$(risk_type_ind)$(risk_val_ind).jld2\", dict_endog_new)\n\n            end\n        end\n    end\nend\n\n\njulia> default_p1 = default_arr\njulia> default_p1[:, 1, :, :, :, :, :] = zeros(S, 1, 3, 3, 3, 2, 2)\n\njulia> zt_arr_macro = repeat(reshape(zt_arr,(S, T, avg_rbart_size, avg_rtp1_size, 3, 1, 1)), 1, 1, 1, 1, 1, Hbar_size, 2)\n\njulia> Kt_arr = (1 .- default_p1) .* k2t_arr\njulia> Y_args = (nvec, epsilon, alpha)\njulia> Yt_arr = (1 .- default_p1) .* get_Y(Kt_arr, zt_arr_macro, Y_args)\njulia> Ct_arr = (1 .- default_p1) .* get_C(c1t_arr, c2t_arr)\n\njulia> dict_params = Dict(\n        \"yrs_in_per\" => yrs_in_per,\n        \"beta_an\" => beta_an,\n        \"beta\" => beta,\n        \"gamma\" => gamma,\n        \"c_min\" => c_min,\n        \"K_min\" => K_min,\n        \"nvec\" => nvec,\n        \"n1\" => nvec[1],\n        \"n2\" => nvec[2],\n        \"alpha\" => alpha,\n        \"epsilon\" => epsilon,\n        \"delta_an\" => delta_an,\n        \"delta\" => delta,\n        \"rho_an\" => rho_an,\n        \"rho\" => rho,\n        \"mu_an\" => mu_an,\n        \"sigma_an\" => sigma_an,\n        \"sigma\" => sigma,\n        \"mu\" => mu,\n        \"A_min\" => A_min,\n        \"z_min\" => z_min,\n        \"Hbar_vec\" => Hbar_vec,\n        \"Hbar_size\" => Hbar_size,\n        \"Hbar\" => Hbar,\n        \"tau\" => tau,\n        \"T\" => T,\n        \"S\" => S,\n        \"rand_seed\" => rand_seed,\n        \"max_cores\" => max_cores,\n        \"num_workers\" => num_workers,\n        \"avg_rtp1_size\" => avg_rtp1_size,\n        \"avg_rtp1_an_vec\" => avg_rtp1_an_vec,\n        \"avg_Rtp1_vec\" => avg_Rtp1_vec,\n        \"avg_rbart_size\" => avg_rbart_size,\n        \"avg_rbart_an_vec\" => avg_rbart_an_vec,\n        \"avg_Rbart_vec\" => avg_Rbart_vec,\n        \"avgRtp1_mat\" => avgRtp1_mat,\n        \"avgRbart_mat\" => avgRbart_mat,\n        \"avgRtp1_gt_avgRbart\" => avgRtp1_gt_avgRbart,\n        \"mu_vec\" => mu_vec,\n        \"mu_mat\" => mu_mat,\n        \"mu_arr\" => mu_arr,\n        \"beta_vec\" => beta_vec,\n        \"beta_mat\" => beta_mat,\n        \"gamma_mat\" => gamma_mat,\n        \"x1_mat\" => x1_mat,\n        \"x1_arr\" => x1_arr,\n        \"kbar2_mat\" => kbar2_mat,\n        \"sigma_vec\" => sigma_vec,\n        \"ExpA\" => ExpA)\n\njulia> dict_endog = Dict(\n        \"unif_mat\" => unif_mat,\n        \"zt_arr\" => zt_arr ,\n        \"c1t_arr\" =>  c1t_arr,\n        \"c2t_arr\"=>  c2t_arr,\n        \"ut_arr\" =>  ut_arr,\n        \"Ht_arr\" =>  Ht_arr,\n        \"wt_arr\" =>  wt_arr,\n        \"rt_arr\" =>  rt_arr,\n        \"rbart_arr\" =>  rbart_arr,\n        \"rbart_an_arr\" => rbart_an_arr,\n        \"k2t_arr\" =>  k2t_arr,\n        \"EulErr_arr\" =>  EulErr_arr,\n        \"Kt_arr\" => Kt_arr,\n        \"Yt_arr\"=> Yt_arr,\n        \"Ct_arr\" => Ct_arr,\n        \"default_arr\" =>  default_arr,\n        \"s_ind_arr\" =>  s_ind_arr)\n\nresults_sims = Dict(\"dict_params\" => dict_params, \"dict_endog\" => dict_endog)\nsave(\"results_sims.jld2\", results_sims)","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"After running the tables file (which can also be found in case number 1), we get the following output :","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"(Image: Table4)","category":"page"},{"location":"","page":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","title":"Replication of \"Public Debt, Interest Rates, and Negative Shocks\" (Evans, R. 2020)","text":"end","category":"page"}]
}
