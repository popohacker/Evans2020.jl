<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Replication of &quot;Public Debt, Interest Rates, and Negative Shocks&quot; (Evans, R. 2020) · Evans2020.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Evans2020.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Replication of &quot;Public Debt, Interest Rates, and Negative Shocks&quot; (Evans, R. 2020)</a><ul class="internal"><li><a class="tocitem" href="#Case-number-1-:-\\varepsilon-1-and-\\mu-is-constant"><span>Case number 1 : <span>$\varepsilon$</span> = 1 and <span>$\mu$</span> is constant</span></a></li><li><a class="tocitem" href="#Case-number-2-:-\\varepsilon-\\infty-and-\\mu-is-constant"><span>Case number 2 : <span>$\varepsilon = \infty$</span> and <span>$\mu$</span> is constant</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Replication of &quot;Public Debt, Interest Rates, and Negative Shocks&quot; (Evans, R. 2020)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Replication of &quot;Public Debt, Interest Rates, and Negative Shocks&quot; (Evans, R. 2020)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/popohacker/Evans2020.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Replication-of-&quot;Public-Debt,-Interest-Rates,-and-Negative-Shocks&quot;-(Evans,-R.-2020)"><a class="docs-heading-anchor" href="#Replication-of-&quot;Public-Debt,-Interest-Rates,-and-Negative-Shocks&quot;-(Evans,-R.-2020)">Replication of &quot;Public Debt, Interest Rates, and Negative Shocks&quot; (Evans, R. 2020)</a><a id="Replication-of-&quot;Public-Debt,-Interest-Rates,-and-Negative-Shocks&quot;-(Evans,-R.-2020)-1"></a><a class="docs-heading-anchor-permalink" href="#Replication-of-&quot;Public-Debt,-Interest-Rates,-and-Negative-Shocks&quot;-(Evans,-R.-2020)" title="Permalink"></a></h1><blockquote><p>This replication study was part of our evaluation for the course <a href="https://floswald.github.io/NumericalMethods/">Numerical Methods</a> at SciencesPo Paris in Spring 2021</p><p>The functions used to replicate this paper are:</p></blockquote><article class="docstring"><header><a class="docstring-binding" id="Evans2020.LN_pdf-Tuple{Any, Any, Any}" href="#Evans2020.LN_pdf-Tuple{Any, Any, Any}"><code>Evans2020.LN_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LN_pdf</p><pre><code class="language-none">This function gives the PDF of the lognormal distribution for xvals
given mu and sigma
(LN): f(x; mu, sigma) = (1 / (x * sigma * sqrt(2 * pi))) *
        exp((-1 / 2) * (((log(x) - mu) / sigma) ** 2))
       x in [0, infty), mu in (-infty, infty), sigma &gt; 0

INPUTS:
xvals = (N,) vector, data
mu    = scalar, mean of the ln(x)
sigma = scalar &gt; 0, standard deviation of ln(x)
OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None
OBJECTS CREATED WITHIN FUNCTION:
pdf_vals        = (N,) vector, probability of each observation given
                  the parameter values
FILES CREATED BY THIS FUNCTION: None
RETURNS: pdf_vals</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L336-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_1pr_MU_c2_pdf-Tuple{Any, Any}" href="#Evans2020.get_1pr_MU_c2_pdf-Tuple{Any, Any}"><code>Evans2020.get_1pr_MU_c2_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_1pr_MU_c2_pdf</code>     This function is the target for calculating the integral     (expectation): E[(1+r<em>{tp1})*(c</em>{2,t+1})<strong>(-gamma)]. This function     returns the value of     (1 + r<em>{tp1})*((c</em>{2,t+1})</strong>(-gamma)) * pdf(A|mu,sigma)     for a given value of A and k2tp1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L364-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_C-Tuple{Any, Any}" href="#Evans2020.get_C-Tuple{Any, Any}"><code>Evans2020.get_C</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_C</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_Eul_err-Tuple{Any, Any}" href="#Evans2020.get_Eul_err-Tuple{Any, Any}"><code>Evans2020.get_Eul_err</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_Eul_err</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L445-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_ExpMU_c2_b-Tuple{Any, Any, Any}" href="#Evans2020.get_ExpMU_c2_b-Tuple{Any, Any, Any}"><code>Evans2020.get_ExpMU_c2_b</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_ExpMU_c2_b</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L431-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_ExpMU_c2tp1_k-Tuple{Any, Any, Any}" href="#Evans2020.get_ExpMU_c2tp1_k-Tuple{Any, Any, Any}"><code>Evans2020.get_ExpMU_c2tp1_k</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_ExpMU_c2tp1_k</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L419-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_Hbar_err-Tuple{Any, Any}" href="#Evans2020.get_Hbar_err-Tuple{Any, Any}"><code>Evans2020.get_Hbar_err</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_Hbar_err</code>     This function is the error function that solves for the current     period shock that sets w * n1 + x1 - c<em>min - K</em>min = Hbar. This is     the minimum shock that does not create default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_Ht-Tuple{Any, Any}" href="#Evans2020.get_Ht-Tuple{Any, Any}"><code>Evans2020.get_Ht</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_Ht</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L158-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_MU_c2_pdf-Tuple{Any, Any}" href="#Evans2020.get_MU_c2_pdf-Tuple{Any, Any}"><code>Evans2020.get_MU_c2_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_MU_c2_pdf</code> 	This function is the target for calculating the integral (expectation): E[(c<em>{2,t+1})^(-gamma)].  	This function returns the value of ((c</em>{2,t+1})^(-gamma)) * pdf(A|mu,sigma) for a given value of A and k2tp1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_MUc_CRRA-Tuple{Any, Any}" href="#Evans2020.get_MUc_CRRA-Tuple{Any, Any}"><code>Evans2020.get_MUc_CRRA</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_MUc_CRRA</code></p><pre><code class="language-none">Generate marginal utility(ies) of consumption with CRRA consumption
utility and stitched function at lower bound such that the new
hybrid function is defined over all consumption on the real
line but the function has similar properties to the Inada condition.
u&#39;(c) = c ** (-sigma) if c &gt;= epsilon
  	      = g&#39;(c) = 2 * b2 * c + b1 if c &lt; epsilon
such that g&#39;(epsilon) = u&#39;(epsilon)
and g&#39;&#39;(epsilon) = u&#39;&#39;(epsilon)
u(c) = (c ** (1 - sigma) - 1) / (1 - sigma)
g(c) = b2 * (c ** 2) + b1 * c + b0

INPUTS:
c  = scalar, individual consumption in a particular period
gamma = scalar &gt;= 1, coefficient of relative risk aversion for CRRA
      utility function: (c ^ (1-gamma) - 1) / (1 - gamma)

OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None
OBJECTS CREATED WITHIN FUNCTION:
epsilon    = scalar &gt; 0, positive value close to zero
c_s        = scalar, individual consumption
c_s_cnstr  = boolean, =True if c_s &lt; epsilon
b1         = scalar, intercept value in linear marginal utility
b2         = scalar, slope coefficient in linear marginal utility
MU_c       = scalar or (p,) vector, marginal utility of consumption
         or vector of marginal utilities of consumption
p          = integer &gt;= 1, number of periods remaining in lifetime
cvec_cnstr = (p,) boolean vector, =True for values of cvec &lt; epsilon

RETURNS: MU_c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L236-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_Y-Tuple{Any, Any, Any}" href="#Evans2020.get_Y-Tuple{Any, Any, Any}"><code>Evans2020.get_Y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Y(k2t, zt, args)

Calculate aggregate output

INPUTS:
Kt   =
Lt   =
zt   =
args =
RETURNS: Yt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L80-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_c1mgam-Tuple{Any, Any}" href="#Evans2020.get_c1mgam-Tuple{Any, Any}"><code>Evans2020.get_c1mgam</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_c1mgam</code></p><pre><code class="language-none">Generate marginal utility(ies) of consumption with CRRA consumption
utility and stitched function at lower bound such that the new
hybrid function is defined over all consumption on the real
line but the function has similar properties to the Inada condition.
f(c) = c ** (1-sigma) if c &gt;= epsilon
g(c) = b2 * c + b1    if c &lt; epsilon
    such that g(epsilon) = f(epsilon)
    and g&#39;(epsilon) = f&#39;(epsilon)
    f(c) = c ** (1 - sigma)
    g(c) = b2 * c + b1
    s.t. b2 = (1 - gamma) * (epsilon ** (-gamma))
         b1 = epsilon**(-gamma) - (1-gamma) * (epsilon ** (1-gamma))

INPUTS:
c  = scalar, individual consumption in a particular period
gamma = scalar &gt;= 1, coefficient of relative risk aversion for CRRA
        utility function: (c**(1-gamma) - 1) / (1 - gamma)

OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None
OBJECTS CREATED WITHIN FUNCTION:
epsilon    = scalar &gt; 0, positive value close to zero
b1         = scalar, intercept value in linear marginal utility
b2         = scalar, slope coefficient in linear marginal utility
MU_c       = scalar or (p,) vector, marginal utility of consumption
             or vector of marginal utilities of consumption
p          = integer &gt;= 1, number of periods remaining in lifetime
cvec_cnstr = (p,) boolean vector, =True for values of cvec &lt; epsilon

RETURNS: f_c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L287-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_c2t-Tuple{Any, Any, Any}" href="#Evans2020.get_c2t-Tuple{Any, Any, Any}"><code>Evans2020.get_c2t</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_c2t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L220-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_c2tp1_1mgam_pdf-Tuple{Any, Any}" href="#Evans2020.get_c2tp1_1mgam_pdf-Tuple{Any, Any}"><code>Evans2020.get_c2tp1_1mgam_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_c2tp1_1mgam_pdf</code> 	This function is the target for calculating the integral (expectation): E[(c<em>{2,t+1})^(1-gamma)].  	This function returns the value of ((c</em>{2,t+1})^(1-gamma)) * pdf(A|mu,sigma) for a given value of A and k2tp1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L403-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_k2tp1-Tuple{Any, Any, Any}" href="#Evans2020.get_k2tp1-Tuple{Any, Any, Any}"><code>Evans2020.get_k2tp1</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_k2tp1</p><pre><code class="language-none">Solve for k2tp1
c1t + k2tp1 = wt * n1 - tau * w1 * n1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L469-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_r-Tuple{Any, Any, Any}" href="#Evans2020.get_r-Tuple{Any, Any, Any}"><code>Evans2020.get_r</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_r</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L138-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_w-Tuple{Any, Any, Any}" href="#Evans2020.get_w-Tuple{Any, Any, Any}"><code>Evans2020.get_w</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_w</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L119-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.get_zstar-Tuple{Any, Any, Any}" href="#Evans2020.get_zstar-Tuple{Any, Any, Any}"><code>Evans2020.get_zstar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_zstar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L197-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.sim_timepath-NTuple{28, Any}" href="#Evans2020.sim_timepath-NTuple{28, Any}"><code>Evans2020.sim_timepath</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sim_timepath </p><pre><code class="language-none">Runs the simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L568-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Evans2020.trunc_norm_draws" href="#Evans2020.trunc_norm_draws"><code>Evans2020.trunc_norm_draws</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>trunc_norm_draws</code></p><pre><code class="language-none">Draw (N x S) matrix of random draws from a truncated normal
distribution based on a normal distribution with mean mu and
standard deviation sigma and cutoffs (cut_lb, cut_ub). These draws
correspond to an (N x S) matrix of randomly generated draws from a
uniform distribution U(0,1).

INPUTS:
unif_vals = (N, S) matrix, (N,) vector, or scalar in (0,1), random
            draws from uniform U(0,1) distribution
mu        = scalar, mean of the nontruncated normal distribution
            from which the truncated normal is derived
sigma     = scalar &gt; 0, standard deviation of the nontruncated
            normal distribution from which the truncated normal is
            derived
cut_lb    = scalar or string, =&#39;None&#39; if no lower bound cutoff is
            given, otherwise is scalar lower bound value of
            distribution. Values below this cutoff have zero
            probability
cut_ub    = scalar or string, =&#39;None&#39; if no upper bound cutoff is
            given, otherwise is scalar lower bound value of
            distribution. Values below this cutoff have zero
            probability
OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:
    scipy.stats.norm()
OBJECTS CREATED WITHIN FUNCTION:
cut_ub_cdf  = scalar in [0, 1], cdf of N(mu, sigma) at upper bound
              cutoff of truncated normal distribution
cut_lb_cdf  = scalar in [0, 1], cdf of N(mu, sigma) at lower bound
              cutoff of truncated normal distribution
unif2_vals  = (N, S) matrix, (N,) vector, or scalar in (0,1),
              rescaled uniform derived from original.
tnorm_draws = (N, S) matrix, (N,) vector, or scalar in (0,1),
              values drawn from truncated normal PDF with base
              normal distribution N(mu, sigma) and cutoffs
              (cut_lb, cut_ub)
FILES CREATED BY THIS FUNCTION: None
RETURNS: tnorm_draws</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/popohacker/Evans2020.jl/blob/35dd15da5aa9f528c2e6dd978560436262d20dc9/src/Evans2020.jl#L17-L58">source</a></section></article><h2 id="Case-number-1-:-\\varepsilon-1-and-\\mu-is-constant"><a class="docs-heading-anchor" href="#Case-number-1-:-\\varepsilon-1-and-\\mu-is-constant">Case number 1 : <span>$\varepsilon$</span> = 1 and <span>$\mu$</span> is constant</a><a id="Case-number-1-:-\\varepsilon-1-and-\\mu-is-constant-1"></a><a class="docs-heading-anchor-permalink" href="#Case-number-1-:-\\varepsilon-1-and-\\mu-is-constant" title="Permalink"></a></h2><p>We run a simulation aiming at capturing the effect on realized lifetime utility of a government transer program. We look at the difference between the baseline model when there is no government transer and a model where the transfer is 5 percent of average savings. </p><p>In the case where <span>$\varepsilon$</span> = 1, we have a Cobb-Douglas productivity function.  And <span>$\mu$</span>, which capturates the riskiness of returns <span>$E[R_{t+1}]$</span>, is constant and equal to 1.0786.</p><p>We simulate 15 time series of 25 periods each and compute the average interest rates. </p><pre><code class="language-julia">julia&gt; using Evans2020

julia&gt; include(&quot;FUNC_NPC.jl&quot;)

# Create OUTPUT directory if does not already exist
julia&gt;  cur_path = string(@__DIR__)
julia&gt;  output_fldr = &quot;OUTPUT&quot;
julia&gt;  output_dir = joinpath(cur_path, output_fldr)
julia&gt;  if !ispath(output_dir)
         mkpath(output_dir)
        end 

###
#------------------------------------------------------------------------
#Set exogenous parameters
#------------------------------------------------------------------------
#yrs_in_per = integer &gt;= 1, number of years in a model period
#beta_an    = scalar in (0, 1), annual discount factor
#beta       = scalar in (0, 1), model period discount factor
#gamma      = scalar &gt;= 1, coefficient of relative risk aversion
#c_min      = scalar &gt; 0, minimum individual consumption
#K_min      = scalar &gt; 0, minimum aggregate capital stock
#n_1        = scalar &gt;= 0, exogenous labor supply when young
#n_2        = scalar &gt;= 0, exogenous labor supply when old
#n_vec      = (2,) vector, lifetime exogenous labor supply
#alpha      = scalar in (0, 1), capital share of income
#delta_an   = scalar in (0, 1], annual depreciation rate
#delta      = scalar in (0, 1], model period depreciation rate
#rho_an     = scalar in (-1, 1), annual persistence of normally
#             distributed TFP process
#rho        = scalar in (-1, 1), model period persistence of normally
#             distributed TFP process
#mu         = scalar, unconditional mean of normally distributed TFP
#             process
#sigma_an   = scalar &gt; 0, annual standard deviation of normally
#             distributed TFP process
#rho_sum    = scalar, recursive geometric sum of rho ** 2
#y_ind      = integer &gt;= 0, index of yrs_in_per
#sigma      = scalar &gt; 0, model period standard deviation of normally
#             distributed TFP process
#A_min      = scalar &gt;= 0, minimum value in support of lognormally
#             distributed TFP process
#z_min      = scalar, minimum value in support of normally distributed
#             TFP process
#Hbar_vec   = (Hbar_size,) vector, values of Hbar
#Hbar_size  = integer &gt;= 1, number of values of Hbar
#k20_vec    = (Hbar_size,) vector, values of k20
#k20_size   = integer &gt;= 1, number of values of k20_vec
#z0         = scalar, initial normally distributed TFP value
#T          = integer &gt; 1, maximum number of periods to simulate
#S          = integer &gt;= 1, number of simulations
#rand_seed  = integer &gt; 0, random seed for simulation
#------------------------------------------------------------------------
#&#39;&#39;&#39;

julia&gt;  yrs_in_per = 25
julia&gt;  beta_an = 0.96
julia&gt;  beta = beta_an^yrs_in_per
julia&gt;  gamma = 2.2
julia&gt;  c_min = 1e-5
julia&gt;  K_min = 1e-5

# Firm parameters
julia&gt;  alpha = 1/3
julia&gt;  epsilon = 1.0  # Inf
julia&gt;  delta_an = 0.0
julia&gt;  delta = 1 - ((1 - delta_an)^yrs_in_per)
julia&gt;  nvec = Array([1.0, 0.0])

# Aggregate shock z parameters
julia&gt;  rho_an = 0.95
julia&gt;  rho = rho_an^yrs_in_per
julia&gt;  mu_an = 0.0
julia&gt;  sigma_an = 0.2  # 0.4946
julia&gt;  rho_sum = 0.0
julia&gt;  rho2_sum = 0.0
julia&gt;  for y_ind in range(0,stop = (yrs_in_per-1),step = 1)
            rho_sum = rho_sum + rho_an^y_ind
            rho2_sum = rho2_sum + rho_an^(2*y_ind)
        end 
julia&gt;  sigma = sqrt(rho2_sum*(sigma_an^2))
julia&gt;  mu = mu_an*rho_sum
julia&gt;  A_min = 0.0
julia&gt;  if A_min == 0.0
             z_min = -Inf
        elseif (A_min &gt; 0.0) &amp;&amp; (A_min &lt; exp(mu))
              z_min = log(A_min)
        elseif A_min &gt;= exp(mu)
        print(&quot;Parameter Error: A_min &gt;= e^(mu)&quot;)
        end
        

# Set government parameters, transfer parameters, and initial values
julia&gt;  Hbar_vec = Array([0.0, 0.05])
# self.Hbar_vec = Array([0.0, 0.05, 0.11, 0.17])
julia&gt;  Hbar_size = length(Hbar_vec)
julia&gt;  Hbar = Hbar_vec[1]
julia&gt;  tau = nothing
julia&gt;  z0 = mu

# Set simulation parameters
julia&gt;  T = 25
julia&gt;  S = 15
julia&gt;  rand_seed = 25

# print(&quot;sigma&quot;)
# print(sigma)
# print(&quot; &quot;)
# print(&quot;beta&quot;)
# print(beta)
# print(&quot; &quot;)


&quot;&quot;&quot;
------------------------------------------------------------------------
Calibrate beta, mu, gamma
------------------------------------------------------------------------
&quot;&quot;&quot;

julia&gt;  avg_rtp1_size = 3
julia&gt;  avg_rtp1_an_vec = Array(range(0.00,stop = 0.04,length = avg_rtp1_size))
julia&gt;  avg_Rtp1_vec = (1 .+ avg_rtp1_an_vec).^yrs_in_per
julia&gt;  avg_rbart_size = 3
julia&gt;  avg_rbart_an_vec = Array(range(-0.02,stop = 0.01, length = avg_rbart_size))
julia&gt;  avg_Rbart_vec = (1 .+ avg_rbart_an_vec).^yrs_in_per

# print(&quot;avg_Rtp1_vec&quot;)
# print(avg_Rtp1_vec)
# print(&quot; &quot;)
# print(&quot;avg_Rbart_vec&quot;)
# print(avg_Rbart_vec)
# print(&quot; &quot;)

julia&gt;  avgRtp1_mat = repeat(reshape(avg_Rtp1_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)
julia&gt;  avgRbart_mat = repeat(reshape(avg_Rbart_vec,(1, avg_rbart_size)), avg_rtp1_size, 1)
julia&gt;  avgRtp1_gt_avgRbart = ((avgRtp1_mat - avgRbart_mat) .&gt; 0) 
# print(avgRtp1_gt_avgRbart)

# Calibrate mu using linear production expected MPK
julia&gt;  mu_vec = 1.0786 .* fill!(similar(avg_Rtp1_vec), 1)
# mu_vec = log.(avg_Rtp1_vec) .- log(alpha) .- ((sigma^2) / 2)
julia&gt;  mu_mat = repeat(reshape(mu_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)
julia&gt;  mu_mat[.!avgRtp1_gt_avgRbart] .= NaN 

# Calibrate beta using Cobb-Douglas expected values expression for beta
julia&gt;  beta_vec = (alpha / (1 - alpha)) .* (1 ./ (2 * avg_Rtp1_vec)) 
julia&gt;  beta_an_vec = beta_vec.^(1 / yrs_in_per)
julia&gt;  beta_mat = repeat(reshape(beta_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)
julia&gt;  beta_mat[.!avgRtp1_gt_avgRbart] .=  NaN

# Calibrate gamma
julia&gt;  gamma_mat = ((log.(avgRtp1_mat) - log.(avgRbart_mat)) ./ (sigma^2))
julia&gt;  gamma_mat[.!avgRtp1_gt_avgRbart]  .=  NaN

# Calibrate x_1
julia&gt;  x1_mat = (((1 - alpha) * exp.(mu_mat .+ ((sigma ^ 2) / 2)) .* ((2 * beta_mat) .^alpha)) .^ (1 / (1 - alpha)))

# Calibrate kbar_2
julia&gt;  kbar2_mat = 2 .* beta_mat .* x1_mat
julia&gt;  Hbar_vec[2] = 0.05 * kbar2_mat[1, 1] # 1.0786
# print(&quot;Hbar_vec = &quot;, Hbar_vec)

# Calibrate x_1 array for different values of x1, given calibration
julia&gt;  x1_mat2 = transpose(x1_mat)
julia&gt;  x1_arr = zeros(3, avg_rtp1_size, avg_rbart_size) 
julia&gt;  x1_arr[:, 1, :] = x1_mat2 
julia&gt;  x1_arr[:, 2, :] = 0.5 .* x1_mat2
julia&gt;  x1_arr[:, 3, :] = 0.0 .* x1_mat2 

# Calibrate sigma vector of 5% and 10% increases
julia&gt;  sigma_vec = zeros(3)
julia&gt;  sigma_vec[1] = sigma
julia&gt;  sigma_vec[2] = 1.05 * sigma
julia&gt;  sigma_vec[3] = 1.10 * sigma

# Calibrate corresponding mu_arr that holds the expected value of the
# TFP shock while expanding the variance. If ExpA is the expected value of
# the TFP shock, then ExpA = exp.(mu .+ (sig^2) / 2), then
# log.(ExpA) = mu .+ (sig^2) / 2
julia&gt;  ExpA = mu_mat .+ (sigma ^ 2) / 2
julia&gt;  mu_mat2 = transpose(mu_mat)
julia&gt;  mu_arr = zeros(3, avg_rtp1_size, avg_rbart_size)
julia&gt;  mu_arr[:, 1, :] = mu_mat2
julia&gt;  mu_arr[:, 2, :] = mu_mat2
julia&gt;  mu_arr[:, 3, :] = mu_mat2
# mu_arr[:, :, 2] = ExpA .- (sigma_vec[2] ^ 2) / 2
# mu_arr[:, :, 3] = ExpA .- (sigma_vec[3] ^ 2) / 2

# print(&quot;mu_mat&quot;)
# print(mu_mat)
# print(&quot; &quot;)
# print(&quot;beta_mat&quot;)
# print(beta_mat)
# print(&quot; &quot;)
# print(&quot;gamma_mat&quot;)
# print(gamma_mat)
# print(&quot; &quot;)
# print(&quot;x1_mat&quot;)
# print(x1_mat)
# print(&quot; &quot;)
# print(&quot;kbar2_mat&quot;)
# print(kbar2_mat)
# print(&quot; &quot;)
# print(&quot;x1_arr 1&quot;)
# print(x1_arr[:, :, 1])
# print(&quot; &quot;)
# print(&quot;x1_arr 2&quot;)
# print(x1_arr[:, :, 2])
# print(&quot; &quot;)
# print(&quot;x1_arr 3&quot;)
# print(x1_arr[:, :, 3])
# print(&quot; &quot;)
# print(&quot;sigma_vec&quot;)
# print(sigma_vec)
# print(&quot; &quot;)
# print(&quot;mu_arr 1&quot;)
# print(mu_arr[:, :, 1])
# print(&quot; &quot;)
# print(&quot;mu_arr 2&quot;)
# print(mu_arr[:, :, 2])
# print(&quot; &quot;)
# print(&quot;mu_arr 3&quot;)
# print(mu_arr[:, :, 3])
# print(&quot; &quot;)

julia&gt;  default_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)

julia&gt;  Random.seed!(rand_seed) 
julia&gt;  unif_mat = rand(Uniform(0, 1), (S, T))

# First three dimensions of zt_arr correspond to mu_arr in different order
julia&gt;  zt_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3)

julia&gt;  cut_lb = 0
julia&gt;  eps_t = 0
julia&gt;  z_t = 0
julia&gt;  z_tm1 = 0

julia&gt;  for sig_ind in range(1, stop=(3), step=1)
            sigma = sigma_vec[sig_ind]
             for avgrtp1_ind in range(1, stop=(avg_rtp1_size), step=1)
                for avgrbart_ind in range(1, stop=(avg_rbart_size), step=1)
                  mu = mu_arr[avgrbart_ind, sig_ind, avgrtp1_ind]
                    for s_ind in range(1, stop=(S), step=1)
                         for t_ind in range(1, stop=(T), step=1)
                            unif = unif_mat[s_ind, t_ind]
                                 if t_ind == 1 &amp;&amp; avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true
                                    cut_lb = z_min - mu
                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)
                                    z_t = mu + eps_t
                                 elseif ((t_ind &gt; 1) &amp;&amp; avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true)
                                    z_tm1 = zt_arr[s_ind, t_ind - 1, avgrbart_ind, avgrtp1_ind, sig_ind]
                                    cut_lb = z_min - rho * z_tm1 - (1 - rho) * mu
                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)
                                     z_t = rho * z_tm1 + (1 - rho) * mu .+ eps_t 
                                  else
                                      z_t = NaN
                                  end
                             zt_arr[s_ind, t_ind, avgrbart_ind,  avgrtp1_ind, sig_ind] = z_t  
                           end 
                        end 
                     end 
                 end 
            end 

julia&gt;  c1t_arr = zero(default_arr)
julia&gt;  c2t_arr = zero(default_arr)
julia&gt;  ut_arr = zeros(S, T - 1, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)
julia&gt;  Ht_arr = zero(default_arr)
julia&gt;  wt_arr = zero(default_arr)
julia&gt;  rt_arr = zero(default_arr)
julia&gt;  k2t_arr = zero(default_arr)
julia&gt;  rbart_arr = zero(default_arr)
julia&gt;  rbart_an_arr = zero(default_arr)
julia&gt;  EulErr_arr = zero(default_arr)
julia&gt;  PathTime_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)
julia&gt;  s_ind_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)

julia&gt;  for rtp1_ind in range(1, stop=(avg_rtp1_size), step=1) 
            for rbart_ind in range(1, stop=(avg_rbart_size), step=1) 
                 kbar2_mat2 = (!iszero).(kbar2_mat)
                 k2t_arr[:, 1, rbart_ind, rtp1_ind, :, :, :] .=  kbar2_mat2[rtp1_ind, rbart_ind]
            end
        end

julia&gt;  mu_in = 0
julia&gt;  sigma_in = 0
julia&gt;  x1_in = 0
julia&gt;  z0_vec_in = 0
julia&gt;  gamma_in = 0
julia&gt;  beta_in = 0
julia&gt;  k20_in = 0
julia&gt;  simulations = 0
julia&gt;  H_ind = 1
julia&gt;  risk_type_ind = 1
julia&gt;  risk_val_ind = 1
julia&gt;  avgrtp1_ind = 1
julia&gt;  avgrbart_ind = 1
julia&gt;  timepaths_s = 0
julia&gt;  for H_ind in 1:Hbar_size
            Hbar_in = Hbar_vec[H_ind]
              for risk_type_ind in 1:2 #0=xval, 1=sigval
                 for risk_val_ind in 1:3
                        for avgrtp1_ind in 1:avg_rtp1_size
                          for avgrbart_ind in 1:avg_rbart_size
                             if avgRtp1_gt_avgRbart[avgrtp1_ind, avgrbart_ind]
                                   simulations = []
                                   beta_in = beta_mat[avgrtp1_ind, avgrbart_ind]
                                   gamma_in = gamma_mat[avgrtp1_ind, avgrbart_ind]
                                   k20_in = kbar2_mat[avgrtp1_ind, avgrbart_ind]
                                  if risk_type_ind == 1
                                        mu_in = mu_mat[avgrtp1_ind, avgrbart_ind]
                                        sigma_in = sigma_vec[1]
                                        x1_in = x1_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]
                                        z0_vec_in = zt_arr[:, 1, avgrbart_ind, avgrtp1_ind, 1]
                                   elseif risk_type_ind == 2 
                                         mu_in = mu_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]
                                         sigma_in = sigma_vec[risk_val_ind]
                                         x1_in = x1_mat[avgrtp1_ind, avgrbart_ind]
                                         z0_vec_in = zt_arr[ :, 1, avgrbart_ind, avgrtp1_ind, risk_val_ind,]
                                    end

                                    for s_ind in 1:S
                                       z0_in = z0_vec_in[s_ind]
                                        if risk_type_ind == 1
                                                zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, 1]
                                        elseif risk_type_ind == 2
                                            zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_type_ind,]
                                        end
                                     timepaths_s = sim_timepath(
                                         Hbar_in, beta_in, gamma_in, k20_in,
                                         sigma_in, x1_in, T, z0_in, z_min, rho,
                                          mu_in, nvec, epsilon, alpha, delta, tau,
                                          c_min, K_min, A_min, yrs_in_per,
                                          H_ind,
                                          risk_type_ind,
                                          risk_val_ind,
                                          avgrtp1_ind,
                                          avgrbart_ind, s_ind,
                                          zt_vec_in,
                                          rand_seed)
                                     push!(simulations, timepaths_s)
                                  end
                        
                        for s_ind in 1:S
                            s_ind_arr[avgrbart_ind, s_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][6] # original S_ind
                            default_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][8]  # default_vec
                            c1t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][9])  # c1t_vec
                            c2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][10])  # c2t_vec
                            ut_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][11]  # ut_vec
                            Ht_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][12])  # Ht_vec
                            wt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][13])  # wt_vec
                            rt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][14])  # rt_vec
                            pop!(simulations[s_ind][15])
                            k2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][15])  #        k2t_vec[:-1]
                            rbart_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][16])  # rbart_vec
                            rbart_an_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][17])  # rbart_an_vec
                            EulErr_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][18])  # EulErr_vec
                        end

                    else  # avg_Rtp1 &lt;= avg_rbart
                        s_ind_arr[avgrbart_ind, :, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN 
                        default_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # default_vec
                        c1t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c1t_vec
                        c2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c2t_vec
                        ut_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # ut_vec
                        Ht_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # Ht_vec
                        wt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # wt_vec
                        rt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rt_vec
                        k2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # k2t_vec[:-1]
                        rbart_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rbart_vec
                        rbart_an_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # rbart_an_vec
                        EulErr_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # EulErr_vec
                    end
                end

            dict_endog_new = Dict(
                &quot;unif_mat&quot; =&gt; unif_mat,
                &quot;zt_arr&quot; =&gt; zt_arr ,
                &quot;c1t_arr&quot; =&gt; c1t_arr,
                &quot;c2t_arr&quot;=&gt; c2t_arr,
                &quot;ut_arr&quot; =&gt; ut_arr,
                &quot;Ht_arr&quot; =&gt; Ht_arr,
                &quot;wt_arr&quot; =&gt; wt_arr,
                &quot;rt_arr&quot; =&gt; rt_arr,
                &quot;rbart_arr&quot; =&gt; rbart_arr,
                &quot;rbart_an_arr&quot; =&gt; rbart_an_arr,
                &quot;k2t_arr&quot; =&gt; k2t_arr,
                &quot;EulErr_arr&quot; =&gt; EulErr_arr,
                &quot;default_arr&quot; =&gt; default_arr,
                &quot;s_ind_arr&quot; =&gt; s_ind_arr)
                  
            save(&quot;dict_endog_$(H_ind)$(risk_type_ind)$(risk_val_ind).jld2&quot;, dict_endog_new)

            end
        end
    end
end


julia&gt; default_p1 = default_arr
julia&gt; default_p1[:, 1, :, :, :, :, :] = zeros(S, 1, 3, 3, 3, 2, 2)

julia&gt; zt_arr_macro = repeat(reshape(zt_arr,(S, T, avg_rbart_size, avg_rtp1_size, 3, 1, 1)), 1, 1, 1, 1, 1, Hbar_size, 2)

julia&gt; Kt_arr = (1 .- default_p1) .* k2t_arr
julia&gt; Y_args = (nvec, epsilon, alpha)
julia&gt; Yt_arr = (1 .- default_p1) .* get_Y(Kt_arr, zt_arr_macro, Y_args)
julia&gt; Ct_arr = (1 .- default_p1) .* get_C(c1t_arr, c2t_arr)

julia&gt; dict_params = Dict(
        &quot;yrs_in_per&quot; =&gt; yrs_in_per,
        &quot;beta_an&quot; =&gt; beta_an,
        &quot;beta&quot; =&gt; beta,
        &quot;gamma&quot; =&gt; gamma,
        &quot;c_min&quot; =&gt; c_min,
        &quot;K_min&quot; =&gt; K_min,
        &quot;nvec&quot; =&gt; nvec,
        &quot;n1&quot; =&gt; nvec[1],
        &quot;n2&quot; =&gt; nvec[2],
        &quot;alpha&quot; =&gt; alpha,
        &quot;epsilon&quot; =&gt; epsilon,
        &quot;delta_an&quot; =&gt; delta_an,
        &quot;delta&quot; =&gt; delta,
        &quot;rho_an&quot; =&gt; rho_an,
        &quot;rho&quot; =&gt; rho,
        &quot;mu_an&quot; =&gt; mu_an,
        &quot;sigma_an&quot; =&gt; sigma_an,
        &quot;sigma&quot; =&gt; sigma,
        &quot;mu&quot; =&gt; mu,
        &quot;A_min&quot; =&gt; A_min,
        &quot;z_min&quot; =&gt; z_min,
        &quot;Hbar_vec&quot; =&gt; Hbar_vec,
        &quot;Hbar_size&quot; =&gt; Hbar_size,
        &quot;Hbar&quot; =&gt; Hbar,
        &quot;tau&quot; =&gt; tau,
        &quot;T&quot; =&gt; T,
        &quot;S&quot; =&gt; S,
        &quot;rand_seed&quot; =&gt; rand_seed,
        &quot;max_cores&quot; =&gt; max_cores,
        &quot;num_workers&quot; =&gt; num_workers,
        &quot;avg_rtp1_size&quot; =&gt; avg_rtp1_size,
        &quot;avg_rtp1_an_vec&quot; =&gt; avg_rtp1_an_vec,
        &quot;avg_Rtp1_vec&quot; =&gt; avg_Rtp1_vec,
        &quot;avg_rbart_size&quot; =&gt; avg_rbart_size,
        &quot;avg_rbart_an_vec&quot; =&gt; avg_rbart_an_vec,
        &quot;avg_Rbart_vec&quot; =&gt; avg_Rbart_vec,
        &quot;avgRtp1_mat&quot; =&gt; avgRtp1_mat,
        &quot;avgRbart_mat&quot; =&gt; avgRbart_mat,
        &quot;avgRtp1_gt_avgRbart&quot; =&gt; avgRtp1_gt_avgRbart,
        &quot;mu_vec&quot; =&gt; mu_vec,
        &quot;mu_mat&quot; =&gt; mu_mat,
        &quot;mu_arr&quot; =&gt; mu_arr,
        &quot;beta_vec&quot; =&gt; beta_vec,
        &quot;beta_mat&quot; =&gt; beta_mat,
        &quot;gamma_mat&quot; =&gt; gamma_mat,
        &quot;x1_mat&quot; =&gt; x1_mat,
        &quot;x1_arr&quot; =&gt; x1_arr,
        &quot;kbar2_mat&quot; =&gt; kbar2_mat,
        &quot;sigma_vec&quot; =&gt; sigma_vec,
        &quot;ExpA&quot; =&gt; ExpA)

julia&gt; dict_endog = Dict(
        &quot;unif_mat&quot; =&gt; unif_mat,
        &quot;zt_arr&quot; =&gt; zt_arr ,
        &quot;c1t_arr&quot; =&gt;  c1t_arr,
        &quot;c2t_arr&quot;=&gt;  c2t_arr,
        &quot;ut_arr&quot; =&gt;  ut_arr,
        &quot;Ht_arr&quot; =&gt;  Ht_arr,
        &quot;wt_arr&quot; =&gt;  wt_arr,
        &quot;rt_arr&quot; =&gt;  rt_arr,
        &quot;rbart_arr&quot; =&gt;  rbart_arr,
        &quot;rbart_an_arr&quot; =&gt; rbart_an_arr,
        &quot;k2t_arr&quot; =&gt;  k2t_arr,
        &quot;EulErr_arr&quot; =&gt;  EulErr_arr,
        &quot;Kt_arr&quot; =&gt; Kt_arr,
        &quot;Yt_arr&quot;=&gt; Yt_arr,
        &quot;Ct_arr&quot; =&gt; Ct_arr,
        &quot;default_arr&quot; =&gt;  default_arr,
        &quot;s_ind_arr&quot; =&gt;  s_ind_arr)

results_sims = Dict(&quot;dict_params&quot; =&gt; dict_params, &quot;dict_endog&quot; =&gt; dict_endog)
save(&quot;results_sims.jld2&quot;, results_sims)</code></pre><p>It gives us the following output : (il faudra mettre notre tableau là)</p><p>We can compare it with the original outpu from the paper : </p><p><img src="tables/originaltab1.png" alt="originaltab1"/></p><h2 id="Case-number-2-:-\\varepsilon-\\infty-and-\\mu-is-constant"><a class="docs-heading-anchor" href="#Case-number-2-:-\\varepsilon-\\infty-and-\\mu-is-constant">Case number 2 : <span>$\varepsilon = \infty$</span> and <span>$\mu$</span> is constant</a><a id="Case-number-2-:-\\varepsilon-\\infty-and-\\mu-is-constant-1"></a><a class="docs-heading-anchor-permalink" href="#Case-number-2-:-\\varepsilon-\\infty-and-\\mu-is-constant" title="Permalink"></a></h2><p>In the case where <span>$\varepsilon = \infty, we have a linear productivity function.  Here, $\mu$</span> is still constant and equal to 1.0786. </p><p>Similarly, we run a simualtion of 15 times series with 25 periods each. </p><pre><code class="language-julia">julia&gt; using Evans2020

julia&gt; include(&quot;FUNC_NPC.jl&quot;)

# Create OUTPUT directory if does not already exist
julia&gt;  cur_path = string(@__DIR__)
julia&gt;  output_fldr = &quot;OUTPUT&quot;
julia&gt;  output_dir = joinpath(cur_path, output_fldr)
julia&gt;  if !ispath(output_dir)
         mkpath(output_dir)
        end 

###
#------------------------------------------------------------------------
#Set exogenous parameters
#------------------------------------------------------------------------
#yrs_in_per = integer &gt;= 1, number of years in a model period
#beta_an    = scalar in (0, 1), annual discount factor
#beta       = scalar in (0, 1), model period discount factor
#gamma      = scalar &gt;= 1, coefficient of relative risk aversion
#c_min      = scalar &gt; 0, minimum individual consumption
#K_min      = scalar &gt; 0, minimum aggregate capital stock
#n_1        = scalar &gt;= 0, exogenous labor supply when young
#n_2        = scalar &gt;= 0, exogenous labor supply when old
#n_vec      = (2,) vector, lifetime exogenous labor supply
#alpha      = scalar in (0, 1), capital share of income
#delta_an   = scalar in (0, 1], annual depreciation rate
#delta      = scalar in (0, 1], model period depreciation rate
#rho_an     = scalar in (-1, 1), annual persistence of normally
#             distributed TFP process
#rho        = scalar in (-1, 1), model period persistence of normally
#             distributed TFP process
#mu         = scalar, unconditional mean of normally distributed TFP
#             process
#sigma_an   = scalar &gt; 0, annual standard deviation of normally
#             distributed TFP process
#rho_sum    = scalar, recursive geometric sum of rho ** 2
#y_ind      = integer &gt;= 0, index of yrs_in_per
#sigma      = scalar &gt; 0, model period standard deviation of normally
#             distributed TFP process
#A_min      = scalar &gt;= 0, minimum value in support of lognormally
#             distributed TFP process
#z_min      = scalar, minimum value in support of normally distributed
#             TFP process
#Hbar_vec   = (Hbar_size,) vector, values of Hbar
#Hbar_size  = integer &gt;= 1, number of values of Hbar
#k20_vec    = (Hbar_size,) vector, values of k20
#k20_size   = integer &gt;= 1, number of values of k20_vec
#z0         = scalar, initial normally distributed TFP value
#T          = integer &gt; 1, maximum number of periods to simulate
#S          = integer &gt;= 1, number of simulations
#rand_seed  = integer &gt; 0, random seed for simulation
#------------------------------------------------------------------------
#&#39;&#39;&#39;

julia&gt;  yrs_in_per = 25
julia&gt;  beta_an = 0.96
julia&gt;  beta = beta_an^yrs_in_per
julia&gt;  gamma = 2.2
julia&gt;  c_min = 1e-5
julia&gt;  K_min = 1e-5

# Firm parameters
julia&gt;  alpha = 1/3
julia&gt;  epsilon = Inf
julia&gt;  delta_an = 0.0
julia&gt;  delta = 1 - ((1 - delta_an)^yrs_in_per)
julia&gt;  nvec = Array([1.0, 0.0])

# Aggregate shock z parameters
julia&gt;  rho_an = 0.95
julia&gt;  rho = rho_an^yrs_in_per
julia&gt;  mu_an = 0.0
julia&gt;  sigma_an = 0.2  # 0.4946
julia&gt;  rho_sum = 0.0
julia&gt;  rho2_sum = 0.0
julia&gt;  for y_ind in range(0,stop = (yrs_in_per-1),step = 1)
            rho_sum = rho_sum + rho_an^y_ind
            rho2_sum = rho2_sum + rho_an^(2*y_ind)
        end 
julia&gt;  sigma = sqrt(rho2_sum*(sigma_an^2))
julia&gt;  mu = mu_an*rho_sum
julia&gt;  A_min = 0.0
julia&gt;  if A_min == 0.0
             z_min = -Inf
        elseif (A_min &gt; 0.0) &amp;&amp; (A_min &lt; exp(mu))
              z_min = log(A_min)
        elseif A_min &gt;= exp(mu)
        print(&quot;Parameter Error: A_min &gt;= e^(mu)&quot;)
        end
        

# Set government parameters, transfer parameters, and initial values
julia&gt;  Hbar_vec = Array([0.0, 0.05])
# self.Hbar_vec = Array([0.0, 0.05, 0.11, 0.17])
julia&gt;  Hbar_size = length(Hbar_vec)
julia&gt;  Hbar = Hbar_vec[1]
julia&gt;  tau = nothing
julia&gt;  z0 = mu

# Set simulation parameters
julia&gt;  T = 25
julia&gt;  S = 15
julia&gt;  rand_seed = 25

# print(&quot;sigma&quot;)
# print(sigma)
# print(&quot; &quot;)
# print(&quot;beta&quot;)
# print(beta)
# print(&quot; &quot;)


&quot;&quot;&quot;
------------------------------------------------------------------------
Calibrate beta, mu, gamma
------------------------------------------------------------------------
&quot;&quot;&quot;

julia&gt;  avg_rtp1_size = 3
julia&gt;  avg_rtp1_an_vec = Array(range(0.00,stop = 0.04,length = avg_rtp1_size))
julia&gt;  avg_Rtp1_vec = (1 .+ avg_rtp1_an_vec).^yrs_in_per
julia&gt;  avg_rbart_size = 3
julia&gt;  avg_rbart_an_vec = Array(range(-0.02,stop = 0.01, length = avg_rbart_size))
julia&gt;  avg_Rbart_vec = (1 .+ avg_rbart_an_vec).^yrs_in_per

# print(&quot;avg_Rtp1_vec&quot;)
# print(avg_Rtp1_vec)
# print(&quot; &quot;)
# print(&quot;avg_Rbart_vec&quot;)
# print(avg_Rbart_vec)
# print(&quot; &quot;)

julia&gt;  avgRtp1_mat = repeat(reshape(avg_Rtp1_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)
julia&gt;  avgRbart_mat = repeat(reshape(avg_Rbart_vec,(1, avg_rbart_size)), avg_rtp1_size, 1)
julia&gt;  avgRtp1_gt_avgRbart = ((avgRtp1_mat - avgRbart_mat) .&gt; 0) 
# print(avgRtp1_gt_avgRbart)

# Calibrate mu using linear production expected MPK
julia&gt;  mu_vec = 1.0786 .* fill!(similar(avg_Rtp1_vec), 1)
# mu_vec = log.(avg_Rtp1_vec) .- log(alpha) .- ((sigma^2) / 2)
julia&gt;  mu_mat = repeat(reshape(mu_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)
julia&gt;  mu_mat[.!avgRtp1_gt_avgRbart] .= NaN 

# Calibrate beta using Cobb-Douglas expected values expression for beta
julia&gt;  beta_vec = (alpha / (1 - alpha)) .* (1 ./ (2 * avg_Rtp1_vec)) 
julia&gt;  beta_an_vec = beta_vec.^(1 / yrs_in_per)
julia&gt;  beta_mat = repeat(reshape(beta_vec,(avg_rtp1_size, 1)), 1, avg_rbart_size)
julia&gt;  beta_mat[.!avgRtp1_gt_avgRbart] .=  NaN

# Calibrate gamma
julia&gt;  gamma_mat = ((log.(avgRtp1_mat) - log.(avgRbart_mat)) ./ (sigma^2))
julia&gt;  gamma_mat[.!avgRtp1_gt_avgRbart]  .=  NaN

# Calibrate x_1
julia&gt;  x1_mat = (((1 - alpha) * exp.(mu_mat .+ ((sigma ^ 2) / 2)) .* ((2 * beta_mat) .^alpha)) .^ (1 / (1 - alpha)))

# Calibrate kbar_2
julia&gt;  kbar2_mat = 2 .* beta_mat .* x1_mat
julia&gt;  Hbar_vec[2] = 0.05 * kbar2_mat[1, 1] # 1.0786
# print(&quot;Hbar_vec = &quot;, Hbar_vec)

# Calibrate x_1 array for different values of x1, given calibration
julia&gt;  x1_mat2 = transpose(x1_mat)
julia&gt;  x1_arr = zeros(3, avg_rtp1_size, avg_rbart_size) 
julia&gt;  x1_arr[:, 1, :] = x1_mat2 
julia&gt;  x1_arr[:, 2, :] = 0.5 .* x1_mat2
julia&gt;  x1_arr[:, 3, :] = 0.0 .* x1_mat2 

# Calibrate sigma vector of 5% and 10% increases
julia&gt;  sigma_vec = zeros(3)
julia&gt;  sigma_vec[1] = sigma
julia&gt;  sigma_vec[2] = 1.05 * sigma
julia&gt;  sigma_vec[3] = 1.10 * sigma

# Calibrate corresponding mu_arr that holds the expected value of the
# TFP shock while expanding the variance. If ExpA is the expected value of
# the TFP shock, then ExpA = exp.(mu .+ (sig^2) / 2), then
# log.(ExpA) = mu .+ (sig^2) / 2
julia&gt;  ExpA = mu_mat .+ (sigma ^ 2) / 2
julia&gt;  mu_mat2 = transpose(mu_mat)
julia&gt;  mu_arr = zeros(3, avg_rtp1_size, avg_rbart_size)
julia&gt;  mu_arr[:, 1, :] = mu_mat2
julia&gt;  mu_arr[:, 2, :] = mu_mat2
julia&gt;  mu_arr[:, 3, :] = mu_mat2
# mu_arr[:, :, 2] = ExpA .- (sigma_vec[2] ^ 2) / 2
# mu_arr[:, :, 3] = ExpA .- (sigma_vec[3] ^ 2) / 2

# print(&quot;mu_mat&quot;)
# print(mu_mat)
# print(&quot; &quot;)
# print(&quot;beta_mat&quot;)
# print(beta_mat)
# print(&quot; &quot;)
# print(&quot;gamma_mat&quot;)
# print(gamma_mat)
# print(&quot; &quot;)
# print(&quot;x1_mat&quot;)
# print(x1_mat)
# print(&quot; &quot;)
# print(&quot;kbar2_mat&quot;)
# print(kbar2_mat)
# print(&quot; &quot;)
# print(&quot;x1_arr 1&quot;)
# print(x1_arr[:, :, 1])
# print(&quot; &quot;)
# print(&quot;x1_arr 2&quot;)
# print(x1_arr[:, :, 2])
# print(&quot; &quot;)
# print(&quot;x1_arr 3&quot;)
# print(x1_arr[:, :, 3])
# print(&quot; &quot;)
# print(&quot;sigma_vec&quot;)
# print(sigma_vec)
# print(&quot; &quot;)
# print(&quot;mu_arr 1&quot;)
# print(mu_arr[:, :, 1])
# print(&quot; &quot;)
# print(&quot;mu_arr 2&quot;)
# print(mu_arr[:, :, 2])
# print(&quot; &quot;)
# print(&quot;mu_arr 3&quot;)
# print(mu_arr[:, :, 3])
# print(&quot; &quot;)

julia&gt;  default_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)

julia&gt;  Random.seed!(rand_seed) 
julia&gt;  unif_mat = rand(Uniform(0, 1), (S, T))

# First three dimensions of zt_arr correspond to mu_arr in different order
julia&gt;  zt_arr = zeros(S, T, avg_rbart_size, avg_rtp1_size, 3)

julia&gt;  cut_lb = 0
julia&gt;  eps_t = 0
julia&gt;  z_t = 0
julia&gt;  z_tm1 = 0

julia&gt;  for sig_ind in range(1, stop=(3), step=1)
            sigma = sigma_vec[sig_ind]
             for avgrtp1_ind in range(1, stop=(avg_rtp1_size), step=1)
                for avgrbart_ind in range(1, stop=(avg_rbart_size), step=1)
                  mu = mu_arr[avgrbart_ind, sig_ind, avgrtp1_ind]
                    for s_ind in range(1, stop=(S), step=1)
                         for t_ind in range(1, stop=(T), step=1)
                            unif = unif_mat[s_ind, t_ind]
                                 if t_ind == 1 &amp;&amp; avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true
                                    cut_lb = z_min - mu
                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)
                                    z_t = mu + eps_t
                                 elseif ((t_ind &gt; 1) &amp;&amp; avgRtp1_gt_avgRbart[avgrtp1_ind,avgrbart_ind] == true)
                                    z_tm1 = zt_arr[s_ind, t_ind - 1, avgrbart_ind, avgrtp1_ind, sig_ind]
                                    cut_lb = z_min - rho * z_tm1 - (1 - rho) * mu
                                    eps_t = trunc_norm_draws(unif, 0, sigma, cut_lb)
                                     z_t = rho * z_tm1 + (1 - rho) * mu .+ eps_t 
                                  else
                                      z_t = NaN
                                  end
                             zt_arr[s_ind, t_ind, avgrbart_ind,  avgrtp1_ind, sig_ind] = z_t  
                           end 
                        end 
                     end 
                 end 
            end 

julia&gt;  c1t_arr = zero(default_arr)
julia&gt;  c2t_arr = zero(default_arr)
julia&gt;  ut_arr = zeros(S, T - 1, avg_rbart_size, avg_rtp1_size, 3, 2, Hbar_size)
julia&gt;  Ht_arr = zero(default_arr)
julia&gt;  wt_arr = zero(default_arr)
julia&gt;  rt_arr = zero(default_arr)
julia&gt;  k2t_arr = zero(default_arr)
julia&gt;  rbart_arr = zero(default_arr)
julia&gt;  rbart_an_arr = zero(default_arr)
julia&gt;  EulErr_arr = zero(default_arr)
julia&gt;  PathTime_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)
julia&gt;  s_ind_arr = zeros(avg_rbart_size, S, avg_rtp1_size, 3, 2, Hbar_size)

julia&gt;  for rtp1_ind in range(1, stop=(avg_rtp1_size), step=1) 
            for rbart_ind in range(1, stop=(avg_rbart_size), step=1) 
                 kbar2_mat2 = (!iszero).(kbar2_mat)
                 k2t_arr[:, 1, rbart_ind, rtp1_ind, :, :, :] .=  kbar2_mat2[rtp1_ind, rbart_ind]
            end
        end

julia&gt;  mu_in = 0
julia&gt;  sigma_in = 0
julia&gt;  x1_in = 0
julia&gt;  z0_vec_in = 0
julia&gt;  gamma_in = 0
julia&gt;  beta_in = 0
julia&gt;  k20_in = 0
julia&gt;  simulations = 0
julia&gt;  H_ind = 1
julia&gt;  risk_type_ind = 1
julia&gt;  risk_val_ind = 1
julia&gt;  avgrtp1_ind = 1
julia&gt;  avgrbart_ind = 1
julia&gt;  timepaths_s = 0
julia&gt;  for H_ind in 1:Hbar_size
            Hbar_in = Hbar_vec[H_ind]
              for risk_type_ind in 1:2 #0=xval, 1=sigval
                 for risk_val_ind in 1:3
                        for avgrtp1_ind in 1:avg_rtp1_size
                          for avgrbart_ind in 1:avg_rbart_size
                             if avgRtp1_gt_avgRbart[avgrtp1_ind, avgrbart_ind]
                                   simulations = []
                                   beta_in = beta_mat[avgrtp1_ind, avgrbart_ind]
                                   gamma_in = gamma_mat[avgrtp1_ind, avgrbart_ind]
                                   k20_in = kbar2_mat[avgrtp1_ind, avgrbart_ind]
                                  if risk_type_ind == 1
                                        mu_in = mu_mat[avgrtp1_ind, avgrbart_ind]
                                        sigma_in = sigma_vec[1]
                                        x1_in = x1_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]
                                        z0_vec_in = zt_arr[:, 1, avgrbart_ind, avgrtp1_ind, 1]
                                   elseif risk_type_ind == 2 
                                         mu_in = mu_arr[avgrbart_ind, risk_val_ind, avgrtp1_ind]
                                         sigma_in = sigma_vec[risk_val_ind]
                                         x1_in = x1_mat[avgrtp1_ind, avgrbart_ind]
                                         z0_vec_in = zt_arr[ :, 1, avgrbart_ind, avgrtp1_ind, risk_val_ind,]
                                    end

                                    for s_ind in 1:S
                                       z0_in = z0_vec_in[s_ind]
                                        if risk_type_ind == 1
                                                zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, 1]
                                        elseif risk_type_ind == 2
                                            zt_vec_in = zt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_type_ind,]
                                        end
                                     timepaths_s = sim_timepath(
                                         Hbar_in, beta_in, gamma_in, k20_in,
                                         sigma_in, x1_in, T, z0_in, z_min, rho,
                                          mu_in, nvec, epsilon, alpha, delta, tau,
                                          c_min, K_min, A_min, yrs_in_per,
                                          H_ind,
                                          risk_type_ind,
                                          risk_val_ind,
                                          avgrtp1_ind,
                                          avgrbart_ind, s_ind,
                                          zt_vec_in,
                                          rand_seed)
                                     push!(simulations, timepaths_s)
                                  end
                        
                        for s_ind in 1:S
                            s_ind_arr[avgrbart_ind, s_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][6] # original S_ind
                            default_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][8]  # default_vec
                            c1t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][9])  # c1t_vec
                            c2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][10])  # c2t_vec
                            ut_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = simulations[s_ind][11]  # ut_vec
                            Ht_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][12])  # Ht_vec
                            wt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][13])  # wt_vec
                            rt_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][14])  # rt_vec
                            pop!(simulations[s_ind][15])
                            k2t_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][15])  #        k2t_vec[:-1]
                            rbart_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][16])  # rbart_vec
                            rbart_an_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][17])  # rbart_an_vec
                            EulErr_arr[s_ind, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] = (!iszero).(simulations[s_ind][18])  # EulErr_vec
                        end

                    else  # avg_Rtp1 &lt;= avg_rbart
                        s_ind_arr[avgrbart_ind, :, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN 
                        default_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # default_vec
                        c1t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c1t_vec
                        c2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # c2t_vec
                        ut_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # ut_vec
                        Ht_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # Ht_vec
                        wt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # wt_vec
                        rt_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rt_vec
                        k2t_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # k2t_vec[:-1]
                        rbart_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # rbart_vec
                        rbart_an_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN  # rbart_an_vec
                        EulErr_arr[:, :, avgrbart_ind, avgrtp1_ind, risk_val_ind, risk_type_ind, H_ind] .= NaN # EulErr_vec
                    end
                end

            dict_endog_new = Dict(
                &quot;unif_mat&quot; =&gt; unif_mat,
                &quot;zt_arr&quot; =&gt; zt_arr ,
                &quot;c1t_arr&quot; =&gt; c1t_arr,
                &quot;c2t_arr&quot;=&gt; c2t_arr,
                &quot;ut_arr&quot; =&gt; ut_arr,
                &quot;Ht_arr&quot; =&gt; Ht_arr,
                &quot;wt_arr&quot; =&gt; wt_arr,
                &quot;rt_arr&quot; =&gt; rt_arr,
                &quot;rbart_arr&quot; =&gt; rbart_arr,
                &quot;rbart_an_arr&quot; =&gt; rbart_an_arr,
                &quot;k2t_arr&quot; =&gt; k2t_arr,
                &quot;EulErr_arr&quot; =&gt; EulErr_arr,
                &quot;default_arr&quot; =&gt; default_arr,
                &quot;s_ind_arr&quot; =&gt; s_ind_arr)
                  
            save(&quot;dict_endog_$(H_ind)$(risk_type_ind)$(risk_val_ind).jld2&quot;, dict_endog_new)

            end
        end
    end
end


julia&gt; default_p1 = default_arr
julia&gt; default_p1[:, 1, :, :, :, :, :] = zeros(S, 1, 3, 3, 3, 2, 2)

julia&gt; zt_arr_macro = repeat(reshape(zt_arr,(S, T, avg_rbart_size, avg_rtp1_size, 3, 1, 1)), 1, 1, 1, 1, 1, Hbar_size, 2)

julia&gt; Kt_arr = (1 .- default_p1) .* k2t_arr
julia&gt; Y_args = (nvec, epsilon, alpha)
julia&gt; Yt_arr = (1 .- default_p1) .* get_Y(Kt_arr, zt_arr_macro, Y_args)
julia&gt; Ct_arr = (1 .- default_p1) .* get_C(c1t_arr, c2t_arr)

julia&gt; dict_params = Dict(
        &quot;yrs_in_per&quot; =&gt; yrs_in_per,
        &quot;beta_an&quot; =&gt; beta_an,
        &quot;beta&quot; =&gt; beta,
        &quot;gamma&quot; =&gt; gamma,
        &quot;c_min&quot; =&gt; c_min,
        &quot;K_min&quot; =&gt; K_min,
        &quot;nvec&quot; =&gt; nvec,
        &quot;n1&quot; =&gt; nvec[1],
        &quot;n2&quot; =&gt; nvec[2],
        &quot;alpha&quot; =&gt; alpha,
        &quot;epsilon&quot; =&gt; epsilon,
        &quot;delta_an&quot; =&gt; delta_an,
        &quot;delta&quot; =&gt; delta,
        &quot;rho_an&quot; =&gt; rho_an,
        &quot;rho&quot; =&gt; rho,
        &quot;mu_an&quot; =&gt; mu_an,
        &quot;sigma_an&quot; =&gt; sigma_an,
        &quot;sigma&quot; =&gt; sigma,
        &quot;mu&quot; =&gt; mu,
        &quot;A_min&quot; =&gt; A_min,
        &quot;z_min&quot; =&gt; z_min,
        &quot;Hbar_vec&quot; =&gt; Hbar_vec,
        &quot;Hbar_size&quot; =&gt; Hbar_size,
        &quot;Hbar&quot; =&gt; Hbar,
        &quot;tau&quot; =&gt; tau,
        &quot;T&quot; =&gt; T,
        &quot;S&quot; =&gt; S,
        &quot;rand_seed&quot; =&gt; rand_seed,
        &quot;max_cores&quot; =&gt; max_cores,
        &quot;num_workers&quot; =&gt; num_workers,
        &quot;avg_rtp1_size&quot; =&gt; avg_rtp1_size,
        &quot;avg_rtp1_an_vec&quot; =&gt; avg_rtp1_an_vec,
        &quot;avg_Rtp1_vec&quot; =&gt; avg_Rtp1_vec,
        &quot;avg_rbart_size&quot; =&gt; avg_rbart_size,
        &quot;avg_rbart_an_vec&quot; =&gt; avg_rbart_an_vec,
        &quot;avg_Rbart_vec&quot; =&gt; avg_Rbart_vec,
        &quot;avgRtp1_mat&quot; =&gt; avgRtp1_mat,
        &quot;avgRbart_mat&quot; =&gt; avgRbart_mat,
        &quot;avgRtp1_gt_avgRbart&quot; =&gt; avgRtp1_gt_avgRbart,
        &quot;mu_vec&quot; =&gt; mu_vec,
        &quot;mu_mat&quot; =&gt; mu_mat,
        &quot;mu_arr&quot; =&gt; mu_arr,
        &quot;beta_vec&quot; =&gt; beta_vec,
        &quot;beta_mat&quot; =&gt; beta_mat,
        &quot;gamma_mat&quot; =&gt; gamma_mat,
        &quot;x1_mat&quot; =&gt; x1_mat,
        &quot;x1_arr&quot; =&gt; x1_arr,
        &quot;kbar2_mat&quot; =&gt; kbar2_mat,
        &quot;sigma_vec&quot; =&gt; sigma_vec,
        &quot;ExpA&quot; =&gt; ExpA)

julia&gt; dict_endog = Dict(
        &quot;unif_mat&quot; =&gt; unif_mat,
        &quot;zt_arr&quot; =&gt; zt_arr ,
        &quot;c1t_arr&quot; =&gt;  c1t_arr,
        &quot;c2t_arr&quot;=&gt;  c2t_arr,
        &quot;ut_arr&quot; =&gt;  ut_arr,
        &quot;Ht_arr&quot; =&gt;  Ht_arr,
        &quot;wt_arr&quot; =&gt;  wt_arr,
        &quot;rt_arr&quot; =&gt;  rt_arr,
        &quot;rbart_arr&quot; =&gt;  rbart_arr,
        &quot;rbart_an_arr&quot; =&gt; rbart_an_arr,
        &quot;k2t_arr&quot; =&gt;  k2t_arr,
        &quot;EulErr_arr&quot; =&gt;  EulErr_arr,
        &quot;Kt_arr&quot; =&gt; Kt_arr,
        &quot;Yt_arr&quot;=&gt; Yt_arr,
        &quot;Ct_arr&quot; =&gt; Ct_arr,
        &quot;default_arr&quot; =&gt;  default_arr,
        &quot;s_ind_arr&quot; =&gt;  s_ind_arr)

results_sims = Dict(&quot;dict_params&quot; =&gt; dict_params, &quot;dict_endog&quot; =&gt; dict_endog)
save(&quot;results_sims.jld2&quot;, results_sims)</code></pre><p>end</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 21 May 2021 21:02">Friday 21 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
